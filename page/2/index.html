<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Was mich nicht umbringt, macht mich stärker">
<meta property="og:type" content="website">
<meta property="og:title" content="Shaw">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Shaw">
<meta property="og:description" content="Was mich nicht umbringt, macht mich stärker">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Shaw">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Shaw</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Shaw</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>resources</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>Schedule</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/14/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-4-%E5%86%B3%E7%AD%96%E4%B8%AD%E7%9A%84%E6%94%B6%E7%9B%8A%E3%80%81%E6%8D%9F%E5%A4%B1%E4%B8%8E%E6%95%88%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/14/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-4-%E5%86%B3%E7%AD%96%E4%B8%AD%E7%9A%84%E6%94%B6%E7%9B%8A%E3%80%81%E6%8D%9F%E5%A4%B1%E4%B8%8E%E6%95%88%E7%94%A8/" class="post-title-link" itemprop="url">贝叶斯统计 4 决策中的收益、损失与效用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-14 12:59:56 / Modified: 15:28:52" itemprop="dateCreated datePublished" datetime="2022-05-14T12:59:56+08:00">2022-05-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Bayesian-Statistics/" itemprop="url" rel="index"><span itemprop="name">Bayesian Statistics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>决策就是对一件事情做决定。它与推断的差别在于是否涉及后果。统计学家在做推断时是按统计理论进行的，很少或者根本不考虑推断结果在使用后的得失。度量得失的尺度就是收益函数或者是损失函数。损失函数与决策环境密切相关，因此从实际中归纳出损失函数就是决策成败的的关键。我们把损失函数引入贝叶斯推断形成贝叶斯决策论。</p>
<p>本章将会重点介绍收益函数、损失函数和效用函数等概念，其中还涉及到一些不用抽样信息的一些决策准则。</p>
<h3 id="S-4-1-决策问题中的三要素"><a href="#S-4-1-决策问题中的三要素" class="headerlink" title="$\S 4.1\ $决策问题中的三要素"></a><center>$\S 4.1\ $决策问题中的三要素</center></h3><p>在现实生活中我们常常会遇到决策问题，例如囚徒困境就是经典的决策问题。在决策过程中，我们总是希望使用一种最优策略，使自己在条件有限的情况下获得最大收益或者承受最小的损失。下面我们通过一个具体的例子来定义一个决策问题，也即讨论它最基本的构成要素。</p>
<p>我们考虑这样一个简单的情景：</p>
<p>某农作物有两个品种：产量高但是抗旱能力弱的品种$\ a_1$，产量低但是抗寒能力强的品种$\ a_2$。为简化问题，先承认这样一个简单的假设：$\ \theta_1\ $表示明年雨量充沛，$\ \theta_2\ $表示明年雨量不充沛。在明年雨量不能被准确预知的情况下，农民应选播哪个品种可以最大化他的收益呢？经过历史经验的归纳总结，农民对自己的收益做了这样的预期</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">预期每亩收益矩阵</th>
<th style="text-align:center">$a_1$：高产不抗旱</th>
<th style="text-align:center">$a_2$：低产抗旱</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\theta_1$：雨量充沛</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">200</td>
</tr>
<tr>
<td style="text-align:center">$\theta_2$：雨量不充沛</td>
<td style="text-align:center">-200</td>
<td style="text-align:center">400</td>
</tr>
</tbody>
</table>
</div>
<p>由上面的情景我们导出构成一个决策问题必有如下三个基本要素：</p>
<ol>
<li>状态集$\ \Theta=\{\theta\}$，其中每个元素$\ \theta\ $表示环境（自然界、社会等）可能出现的一种状态。所有可能状态的全体组成状态集。在选播决策问题中，状态集是由两个状态组成，$\Theta=\{\theta_1,\theta_2\}$，其中$\ \theta_1\ $表示雨量充沛，$\theta_2\ $表示雨量不充沛。</li>
<li>行动集$\ \mathscr{A}=\{a\}$，其中$\ a\ $表示人们可能采取的一种行动。在选播决策问题中，行动集是由两个行动组成，$\mathscr{A}=\{a_1,a_2\}$，其中$\ a_1\ $表示播种高产但抗旱能力差的$(a_1)$，$a_2\ $表示播种抗旱能力强但是产量不高的$(a_2)$。</li>
<li>收益函数$\ Q(\theta,a)\ $度量了当环境处在状态$\ \theta$，而人们采取行动$\ a\ $时的收益。以上的预期每亩收益矩阵就是等价地给出了收益函数。</li>
</ol>
<h3 id="S-4-2-决策准则"><a href="#S-4-2-决策准则" class="headerlink" title="$\S 4.2\  $决策准则"></a><center>$\S 4.2\  $决策准则</center></h3><h4 id="行动的容许性"><a href="#行动的容许性" class="headerlink" title="行动的容许性"></a>行动的容许性</h4><p>首先我们对行动集进行一个简单的划分。考虑这样一个问题，假如在行动集中有这样两个行动$\ a_1$和$\ a_2$，满足对于任意的状态$\ \theta$，都有$\ a_1\ $的收益不少于$\ a_2$。那么很显然，此时我们并没有必要在行动集中保留$\ a_2$，因为它永远不可能作为最优决策被选中。行动$\ a_2\ $被称为非容许行动。</p>
<p>基于这种想法，我们给容许行动一个定义：在给定的决策问题中，$\mathscr{A}\ $中的行动$\ a_1\ $被称为是容许的，如果在$\ \mathscr{A}\ $中不存在满足如下两个条件的行动$\ a_2$：</p>
<ol>
<li>对所有的$\ \theta\in\Theta$，有$\ Q(\theta,a_1)&gt;=Q(\theta,a_2)$</li>
<li>至少有一个$\ \theta$，可使上述不等式严格成立。</li>
</ol>
<p>假如这样的$\ a_2\ $存在的话，则称$\ a_1\ $是非容许的。</p>
<h4 id="决策准则"><a href="#决策准则" class="headerlink" title="决策准则"></a>决策准则</h4><p>悲观准则</p>
<ul>
<li>对每个行动选出最小的收益</li>
<li>在所有选出的最小收益中选取最大值。</li>
</ul>
<p>转化为数学语言就是假如$\ a’\in\mathscr{A}$，且满足</p>
<script type="math/tex; mode=display">
\max_{a\in\mathscr{A}}\min_{\theta\in\Theta}Q(\theta,a)=\min_{\theta\in\Theta}Q(\theta,a')</script><p>那么我们在悲观准则下认为行动$\ a’\ $是最优行动。</p>
<p>悲观准则是一种保守的决策准则。它是在最不利的状态发生的情况下，尽量争取较多的利益。它也反映了决策者的决策性格或是决策者对于未来预期的一种悲观态度。</p>
<blockquote>
<p>将悲观准则应用于选播问题就是</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">预期每亩收益矩阵</th>
<th style="text-align:center">$a_1$：高产不抗旱</th>
<th style="text-align:center">$a_2$：低产抗旱</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\theta_1$：雨量充沛</td>
<td style="text-align:center">×</td>
<td style="text-align:center">200</td>
</tr>
<tr>
<td style="text-align:center">$\theta_2$：雨量不充沛</td>
<td style="text-align:center">-200</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
<p>最终我们选择播种低产抗旱的品种。</p>
</blockquote>
<p>乐观准则</p>
<ul>
<li>对每一个行动选取最大的收益值</li>
<li>在所有选出的最大收益值中选取相对最大值，此最大值对应的行动就是在乐观准则下寻得的最优行动。</li>
</ul>
<p>转化为数学语言就是假如$\ a’\in\mathscr{A}$，且满足</p>
<script type="math/tex; mode=display">
\min_{\theta\in\Theta}\max_{a\in\mathscr{A}}Q(\theta,a)=\min_{\theta\in\Theta}Q(\theta,a')</script><p>那么我们在乐观准则下认为行动$\ a’\ $是最优行动。</p>
<p>乐观准则就是设想最有利的状态发生的情况下，尽量争取最大的收益。另外这种决策准则也反映了决策者比较能够承受风险的态度。</p>
<blockquote>
<p>将乐观准则应用于选播问题就是</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">预期每亩收益矩阵</th>
<th style="text-align:center">$a_1$：高产不抗旱</th>
<th style="text-align:center">$a_2$：低产抗旱</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$\theta_1$：雨量充沛</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center">$\theta_2$：雨量不充沛</td>
<td style="text-align:center">×</td>
<td style="text-align:center">400</td>
</tr>
</tbody>
</table>
</div>
<p>最终我们选择播种高产不抗旱的品种作为最优行动。</p>
</blockquote>
<p>此外还有折中准则，又称$\ Hurwiez\ $准则。</p>
<h3 id="S-4-3-先验期望准则"><a href="#S-4-3-先验期望准则" class="headerlink" title="$\S 4.3\ $先验期望准则"></a><center>$\S 4.3\ $先验期望准则</center></h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《贝叶斯统计》第2版  by 茆诗松，汤银才</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-3-%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E7%9A%84%E7%A1%AE%E5%AE%9A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/08/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-3-%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E7%9A%84%E7%A1%AE%E5%AE%9A/" class="post-title-link" itemprop="url">贝叶斯统计 3 先验分布的确定</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-08 12:35:02" itemprop="dateCreated datePublished" datetime="2022-05-08T12:35:02+08:00">2022-05-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-14 13:04:20" itemprop="dateModified" datetime="2022-05-14T13:04:20+08:00">2022-05-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Bayesian-Statistics/" itemprop="url" rel="index"><span itemprop="name">Bayesian Statistics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="S-3-1-主观概率"><a href="#S-3-1-主观概率" class="headerlink" title="$\S 3.1\ $主观概率"></a><center>$\S 3.1\ $主观概率</center></h3><h4 id="主观概率"><a href="#主观概率" class="headerlink" title="主观概率"></a>主观概率</h4><p>贝叶斯统计中要使用先验信息，而先验信息主要是经验和历史资料。因此如何用人们的经验和过去的历史资料确定概率和先验分布是贝叶斯学派要研究的问题。</p>
<p>贝叶斯学派认为：一个事件的概率是人们根据经验对该事件发生的可能性所给出的个人信念。这样给出的概率称为主观概率。</p>
<p>当然我们所给出的主观概率并不是随意的，而是要求当事人（可能是某一行的专家）对所考察的事件有较透彻的了解和丰富的经验，并能对周围信息和历史信息进行仔细分析，在这个基础上确定的主观概率就能符合实际，这也使得主观概率有别于主观臆断。</p>
<p>主观概率要接受实践检验，也要符合概率的三条公理。</p>
<p>主观概率在经济领域和决策分析中使用较为广泛，因为在那里遇到的随机现象大多是不能大量重复的，无法用频率方法确定事件概率。在这个意义上看，主观概率至少是频率方法和古典方法的一种补充。</p>
<h4 id="确定主观概率的方法"><a href="#确定主观概率的方法" class="headerlink" title="确定主观概率的方法"></a>确定主观概率的方法</h4><ul>
<li>专家的主观概率</li>
<li>概率三条公理</li>
<li>根据对专家的了解（偏保守或激进）形成决策者自己的主观概率</li>
</ul>
<h3 id="S-3-2-利用先验信息确定先验分布"><a href="#S-3-2-利用先验信息确定先验分布" class="headerlink" title="$\S 3.2\ $利用先验信息确定先验分布"></a><center>$\S 3.2\ $利用先验信息确定先验分布</center></h3><p>当总体参数为离散型时，可对每一个点确定一个主观概率。</p>
<p>当总体参数为连续型是，要构造先验密度就比较困难了。当$\ \theta\ $的先验信息足够多时，下面三个方法可供使用：</p>
<ol>
<li><p>频率直方图法（用频率估计概率）</p>
</li>
<li><p>选定先验密度函数形式再估计其超参数</p>
<p>这个方法的要点如下：</p>
<ul>
<li>根据先验信息选定$\ \theta\ $的先验密度函数形式$\ \pi(\theta)\ $的形式，如选其共轭先验分布</li>
<li>当共轭先验分布中含有未知参数（称为超参数）时，譬如$\ \pi(\theta)=\pi(\theta;\alpha,\beta)$，给出超参数$\ \alpha,\beta\ $的估计值使得最接近先验信息</li>
</ul>
<p>这种方法最常用，但也及其容易误用，因为先验密度$\ \pi(\theta)\ $的函数形式选用不当将会导致以后推导失误。</p>
</li>
<li><p>定分度法和变分度法</p>
<p>变分度法是把参数可能取值的区间逐次分为机会相等的两个小区间。</p>
<p>其实也没啥好说的，感兴趣的同学自己查去吧[Doge]</p>
</li>
</ol>
<h3 id="S-3-3-利用边缘分布m-x-确定先验密度"><a href="#S-3-3-利用边缘分布m-x-确定先验密度" class="headerlink" title="$\S 3.3\ $利用边缘分布m(x)确定先验密度"></a><center>$\S 3.3\ $利用边缘分布m(x)确定先验密度</center></h3><p>上一节的东西简直无聊透顶，我其实都不太想写的…幸好比起上一节，这一节的内容还是相对比较有意思的。</p>
<h4 id="边缘分布"><a href="#边缘分布" class="headerlink" title="边缘分布"></a>边缘分布</h4><p>设总体$\ X\ $的密度函数为$\ p(x|\theta)$，它含有未知参数$\ \theta$，若$\ \theta\ $的先验分布选用形式已知的密度函数$\ \pi(\theta)$，则可算得$\ X\ $的边缘分布</p>
<script type="math/tex; mode=display">
m(x)=\left\{
\begin{aligned}
\int_\Theta p(x|\theta)\pi(\theta)d\theta,\quad\text{当$\ \theta$}为连续时\\
\sum_{\theta\in\Theta}p(x|\theta)\pi(\theta),\quad\text{当$\ \theta$}为离散时
\end{aligned}
\right.</script><h4 id="混合分布"><a href="#混合分布" class="headerlink" title="混合分布"></a>混合分布</h4><p>设随机变量$\ X\ $以概率$\ \pi\ $总体$\ F_1\ $中取值，以概率$\ 1-\pi\ $在总体$\ F_2\ $中取值。若$\ F(x|\theta_1)\ $和$\ F(x|\theta_2)\ $分别是这两个总体的分布函数，则$\ X\ $的分布函数为</p>
<script type="math/tex; mode=display">
F(x)=\pi F(x|\theta_1)+(1-\pi)F(x|\theta_2)</script><p>或用密度函数表示</p>
<script type="math/tex; mode=display">
p(x)=\pi p(x|\theta_1)+(1-\pi)p(x|\theta_2)</script><p>这个分布$\ F(x)\ $称为$\ F(x|\theta_1)\ $和$\ F(x|\theta_2)\ $的混合分布。</p>
<p>从混合分布中抽取一个样本$\ x_1$，相当于如下的二次抽样：</p>
<ul>
<li>第一次，从$\ \pi(\theta)\ $中抽取样本$\ \theta$</li>
<li>第二次，若$\ \theta=\theta_1$，则从$\ F(x|\theta_1)\ $中再抽一个样本，这个样本就是$\ x_1$；若$\ \theta=\theta_2$，则从$\ F(x|\theta_2)\ $中再抽一个样本，这个样本就是$\ x_1$.</li>
</ul>
<p>从上述混合分布的定义很容易看出，边缘分布就是混合分布的推广。以后我们就可以将对边缘分布的抽样看成是对广义混合分布的抽样。</p>
<h4 id="先验选择的-ML-Ⅱ-方法"><a href="#先验选择的-ML-Ⅱ-方法" class="headerlink" title="先验选择的$\ ML-Ⅱ\ $方法"></a>先验选择的$\ ML-Ⅱ\ $方法</h4><p>在边缘分布$\ m(x)\ $的表示式中，若$\ p(x|\theta)\ $已知，则$\ m(x)\ $的大小反映了$\ \pi(\theta)\ $的合理程度。这里把$\ m(x)\ $记为$\ m^\pi(x)$。注意到在上一章中，我们将边缘分布函数视为了对$\ x\ $的预测分布。当样本观察值给定时，这件事情就变得更加明朗了：当对不同的两个先验分布$\ \pi_1\ $和$\ \pi_2$，有</p>
<script type="math/tex; mode=display">
m^{\pi_1}(x)>m^{\pi_2}(x)</script><p>时，我们可以认为由先验$\ \pi_1\ $给出的预测分布更加支持样本$\ x\ $的出现。还是利用到极大似然估计的基本观点（自然也是统计学的基本观点）：将最先发生的事情视为最有可能发生的事情。那么我们对$\ \pi_1\ $的偏好也就是合理的了。我们将这样给出的的先验称为$\ Ⅱ\ $型极大似然先验，或称为$\ ML-Ⅱ\ $先验。</p>
<p>例如混合样本$\ \mathbf{x}=(x_1,…,x_n)\ $所涉及的先验密度函数的形式已知，未知的仅是其中的超参数，即先验密度函数族可表示如下：</p>
<script type="math/tex; mode=display">
\Gamma=\{\pi(\theta|\lambda),\lambda\in\Lambda\}</script><p>这时寻求$\ ML-Ⅱ\ $先验是较为简单的事，只要寻求这样的$\ \hat\lambda\ $使得</p>
<script type="math/tex; mode=display">
m(\mathbf{x}|\hat\lambda)=\sup_{\lambda\in\Lambda}\prod_{i=1}^{n}m(x_i|\lambda)</script><p>这可用最大化似然函数方法来实现。</p>
<h4 id="先验选择的矩方法"><a href="#先验选择的矩方法" class="headerlink" title="先验选择的矩方法"></a>先验选择的矩方法</h4><p>当先验密度函数形式已知时，还可以利用先验矩与边缘分布之间的关系寻求超参数的估计。这个方法称为先验选择的矩方法。这个矩方法的要点如下：</p>
<ul>
<li><p>计算总体分布$\ p(x|\theta)\ $的期望$\ \mu(\theta)\ $和方差$\ \sigma^2(\theta)$，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mu(\theta)&=E^{x|\theta}(X)\\
\sigma^2(\theta)&=E^{x|\theta}[X-\mu(\theta)]^2
\end{aligned}</script></li>
<li><p>计算边缘密度$\ m(x|\lambda)\ $的期望$\ \mu_{m}(\lambda)\ $和方差$\ \sigma_{m}^2(\lambda)$，下面的公式可以帮助我们简化这些计算：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mu_m(\lambda)&=E^{x|\lambda}(X)\\
&=\int_\chi x\int_\Theta p(x|\theta)\pi(\theta|\lambda)d\theta dx\\
&=\int_\Theta\int_\chi x p(x|\theta)dx\pi(\theta|\lambda)d\theta\\
&=\int_\Theta\mu(\theta)\pi(\theta|\lambda)d\theta\\
&=E^{\theta|\lambda}[\mu(\theta)]\\

\sigma_m^2(\lambda)&=E^{x|\lambda}[X-\mu_m(\lambda)]^2\\
&=\int_\chi [x-\mu_m(\lambda)]^2\int_\Theta p(x|\theta)\pi(\theta|\lambda)d\theta dx\\
&=\int_\Theta\int_\chi [x-\mu_m(\lambda)]^2
    p(x|\theta)dx\pi(\theta|\lambda)d\theta\\
&=\int_\Theta E^{x|\theta}[x-\mu_m(\lambda)]^2
    \pi(\theta|\lambda)d\theta\\
\end{aligned}</script></li>
</ul>
<p>(to be continued</p>
<h3 id="S-3-4-无信息先验分布"><a href="#S-3-4-无信息先验分布" class="headerlink" title="$\S 3.4\ $无信息先验分布"></a><center>$\S 3.4\ $无信息先验分布</center></h3><p>贝叶斯统计启发人们要充分挖掘周围的各种信息是统计推断更加有效。但是当我们并没有任何先验信息可以利用的情况下，该如何确定先验分布？这时候我们选用需要选用无信息先验。</p>
<p>说到无信息先验，哪怕我们从未听过这个名词，也很自然会联想到均匀分布（连续型）或是在可数离散情形下认为参数等可能。这两种朴素的联想都表明了我们在无知情况下的一种立场：不偏好参数任何可能的取值。不过如果问题真的就这么简单，那我们也没有必要专门用一节来讲这个问题了。下面我们叙述一些主要结果。</p>
<h4 id="贝叶斯假设"><a href="#贝叶斯假设" class="headerlink" title="贝叶斯假设"></a>贝叶斯假设</h4><p>所谓参数$\ \theta\ $的无信息先验分布是指除参数$\ \theta\ $的取值范围$\ \Theta\ $和$\ \theta\ $在总体分布中的地位之外，再也不包含$\ \theta\ $的任何信息的先验分布。有人把“不包含$\ \theta\ $的任何信息”理解为（就如上一段所述）对$\ \theta\ $的任何可能的取值没有任何偏好，都是同样无知的。因此很自然地将$\ \theta\ $的取值范围上的均匀分布看作$\ \theta\ $的先验分布，即</p>
<script type="math/tex; mode=display">
\pi(\theta)=\left\{
\begin{aligned}
c,\quad \theta\in\Theta\\
0,\quad \theta\notin\Theta
\end{aligned}
\right.</script><p>其中$\ \Theta\ $是$\ \theta\ $的取值范围，$c\ $是容易确定的常数。这一看法综合了我们上一段的两种想法，通常被称为贝叶斯假设。</p>
<p>使用贝叶斯假设也会遇到一些麻烦，主要是以下两个：</p>
<ol>
<li>当$\ \theta\ $为无限区间时，在$\ \Theta\ $上无法定义一个正常的均匀分布</li>
<li>贝叶斯假设不满足变换下的不变性</li>
</ol>
<p>第一个问题可以通过引入广义先验密度的方法来解决。它的动机是虽然我们不能得到一个正常的密度函数，但是使用它并不影响后验分布的计算，也就是说采用广义先验密度计算出来的后验密度是一个正常的概率密度。</p>
<p>由此我们定义：</p>
<p>设总体$\ X\sim f(x|\theta),\theta\in\Theta$，若$\ \theta\ $先验分布$\ \pi(\theta)\ $满足下列条件：</p>
<ul>
<li>$\pi(\theta)\ge0$，且$\ \int_\Theta\pi(\theta)d\theta=\infty$</li>
<li>由此决定的后验密度$\ \pi(\theta|x)\ $是一个正常的密度函数，则称$\ \pi(\theta)\ $为$\ \theta\ $的广义先验密度。</li>
</ul>
<p>对于第二个问题，我们先解释一下什么是变换下的不变性。</p>
<p>考虑正态标准差，它的参数空间是$\ (0,\infty)$。若定义一个变换</p>
<script type="math/tex; mode=display">
\eta=\sigma^2\in(0,\infty)</script><p>则$\ \eta\ $是正态方差。注意到这时一个一一变换，不会损失信息。若$\ \sigma\ $是无信息参数，那么$\ \eta\ $也是无信息参数，且它们的参数空间都是$\ (0,\infty)$，没有被压缩或放大。按贝叶斯假设，它们的无信息先验分布应都为常数，应该成比例。可是按照概率运算法则并不是这样的。若设$\ \pi(\sigma)\ $为$\ \sigma\ $的密度函数，那么$\ \eta\ $的密度函数为</p>
<script type="math/tex; mode=display">
\pi^*(\eta)=\abs{\frac{d\sigma}{d\eta}}\pi(\sqrt\eta)=\frac{1}{2\sqrt\eta}\pi(\sqrt\eta)</script><p>因此，若$\ \theta\ $的无信息先验分布被选为常数，为保持数学上逻辑推理的一致性，$\eta\ $的无信息先验应与$\ \eta^{-1/2}\ $成比例。这就与贝叶斯假设矛盾。</p>
<p>从这个例子可以看出，不能随意设定一个常数为某参数的先验分布，即不能随意使用贝叶斯假设。那么什么场合可以使用贝叶斯假设？什么场合不能使用贝叶斯假设？如不能使用贝叶斯假设，无信息先验分布又如何确定呢？下面来叙述这些结果。</p>
<h4 id="位置参数的无信息先验"><a href="#位置参数的无信息先验" class="headerlink" title="位置参数的无信息先验"></a>位置参数的无信息先验</h4><p>若要考虑参数$\ \theta\ $的无信息先验，我们首先要知道该参数$\ \theta\ $在总体分布中的地位，譬如$\ \theta\ $是位置参数，还是尺度参数。根据参数在分布的地位选用适当变换下的不变性来确定无信息先验分布。</p>
<p>设总体$\ X\ $的密度具有形式$\ p(x-\theta)$，其样本空间$\ \chi\ $和参数空间$\ \Theta\ $皆为实数集$\ \mathbb{R}^1$。这类密度函数组成位置参数族。$\theta\ $称为位置参数，方差$\ \sigma^2\ $已知时的正态分布$\ N(\theta,\sigma^2)\ $就是其成员之一。下面我们导出这种场合下$\ \theta\ $的无信息先验分布。</p>
<p>设想让$\ X\ $移动一个量$\ c\ $得到$\ Y=X+c$，同时让参数也移动一个量$\ c\ $得到$\ \eta=\theta+c$，显然$\ Y\ $具有密度$\ p(y-\eta)$。它仍是位置参数族的成员，且其样本空间与参数空间仍为$\ \mathbb{R}^1$。所以$\ (X,\theta)\ $问题与$\ (Y,\eta)\ $问题的统计结构完全相同。因此$\ \theta\ $与$\ \eta\ $应是有相同的无信息先验分布。</p>
<script type="math/tex; mode=display">
\pi(\tau)=\pi^*(\tau)</script><p>其中$\ \pi^{*}(*)\ $为$\ \eta\ $的无信息先验分布，另一方面，由变换$\ \eta=\theta+c\ $可以算出$\ \eta\ $的无信息先验分布为</p>
<script type="math/tex; mode=display">
\pi^*(\eta)=\abs{\frac{d\theta}{d\eta}}\pi(\eta-c)=\pi(\eta-c)</script><p>联立上面两式可得</p>
<script type="math/tex; mode=display">
\pi(\eta)=\pi(\eta-c)</script><p>取$\ \eta=c$，则有</p>
<script type="math/tex; mode=display">
\pi(c)=\pi(0)=\text{常数}</script><p>由于$\ c\ $的任意性，故得$\ \theta\ $的无信息先验分布为</p>
<script type="math/tex; mode=display">
\pi(\theta)=1</script><p>这表明，当$\ \theta\ $为位置参数时，其先验分布可用贝叶斯假设作为无信息先验分布。</p>
<h4 id="尺度参数的无信息先验"><a href="#尺度参数的无信息先验" class="headerlink" title="尺度参数的无信息先验"></a>尺度参数的无信息先验</h4><p>设总体$\ X\ $的密度具有形式$\ \frac{1}{\sigma}p(\frac{x}{\sigma})$，其中$\ \sigma\ $称为尺度参数，参数空间$\ \Theta\ $为$\ \mathbb{R}^+=(0,\infty)$。这类密度函数的全体组成尺度参数族。正态分布$\ N(0,\sigma^2)\ $就属于该分布族。下面我们导出这种场合下参数$\ \sigma\ $的无信息先验分布。</p>
<p>设想让$\ X\ $改变比例尺，即得$\ Y=cX(c&gt;0)$。类似地定义$\ \eta=c\sigma$，即让参数$\ \sigma\ $同步变化，不难算出$\ Y\ $的密度函数为$\ \frac{1}{\eta}p(\frac{y}{\eta})\ $仍属于尺度参数族。易见$\ (X,\sigma)\ $和$\ (Y, \eta)\ $具有相同的统计结构，故两个尺度参数的无信息先验理应相同</p>
<script type="math/tex; mode=display">
\pi(\tau)=\pi^*(\tau)</script><p>另一方面，由变换$\ \eta=c\sigma\ $可得$\ \eta\ $的无信息先验</p>
<script type="math/tex; mode=display">
\pi^*(\eta)=\frac{1}{c}{\pi(\frac{\eta}{c})}</script><p>比较上面两式得</p>
<script type="math/tex; mode=display">
\pi(\eta)=\frac{1}{c}\pi(\frac{\eta}{c})</script><p>取$\ \eta=c$，则有</p>
<script type="math/tex; mode=display">
\pi(c)=\frac{1}{c}\pi(1)</script><p>不妨令$\ \pi(1)=1$，可得$\ \sigma\ $的无信息先验为</p>
<script type="math/tex; mode=display">
\pi(\sigma)=\frac{1}{\sigma},\quad\sigma>0</script><p>这仍然是一个不正常的先验。</p>
<h4 id="用Fisher信息阵确定无信息先验"><a href="#用Fisher信息阵确定无信息先验" class="headerlink" title="用Fisher信息阵确定无信息先验"></a>用Fisher信息阵确定无信息先验</h4><p>$\ Jeffreys\ $还提出确定无信息先验更一般的方法。由于推理涉及到变换群和$\ Harr\ $测度知识，这里仅给出最后结果及其计算步骤</p>
<p>设$\ \mathbf{x}=(x_1,…,x_n)\ $是来自密度函数$\ p(x|\theta)\ $的一个样本。这里$\ \theta=(\theta_1,…,\theta_n)\ $是$\ p\ $维参数向量。在对$\ \theta\ $无先验信息可用时，$\ Jeffreys\ $用$\ Fisher\ $信息阵的平方根作为$\ \theta\ $的无信息分布。这样的无信息先验常称为$\ Jeffreys\ $先验。其寻求步骤如下：</p>
<ol>
<li><p>写出样本的对数似然函数</p>
<script type="math/tex; mode=display">
l(\theta|\mathbf{x})=\ln{[\prod_{i=1}^{n}p(x_i|\theta)]}=\sum_{i=1}^{n}\ln p(x_i|\theta)</script></li>
<li><p>求样本的信息阵</p>
<script type="math/tex; mode=display">
I(\theta)=E^{x|\theta}[-\frac{\part^2 l}{\part\theta_i\part\theta_j}]</script><p>其中$\ i,j=1,2,…,p$。在单参数场合下</p>
<script type="math/tex; mode=display">
I(\theta)=E^{x\theta}[-\frac{\part^2l}{\part\theta^2}]</script></li>
<li><p>$\theta\ $的无信息先验密度为</p>
<script type="math/tex; mode=display">
\pi(\theta)=[\det I(\theta)]^{1/2}</script><p>其中$\ \det I(\theta)\ $表示$\ p\times p\ $阶信息阵$\ I(\theta)\ $的行列式。在单参数场合下</p>
<script type="math/tex; mode=display">
\pi(\theta)=[I(\theta)]^{1/2}</script></li>
</ol>
<h3 id="S-3-5-多层先验"><a href="#S-3-5-多层先验" class="headerlink" title="$\S 3.5\ $多层先验"></a><center>$\S 3.5\ $多层先验</center></h3><h4 id="多层先验"><a href="#多层先验" class="headerlink" title="多层先验"></a>多层先验</h4><p>当所给先验分布中超参数难于确定时，可以对超参数再给出一个先验，第二个先验成为超先验。由先验和超先验决定的一个新先验就称为多层先验。下面的例子可以很好的帮助我们理解多层先验的想法和做法。</p>
<p>设人们对某产品的不合格率了解甚少，只知道它比较小。现需确定$\ \theta\ $的先验分布。决策人经过反复的思考，最后把他引导到多层先验上去，他的思路是这个样子的：</p>
<ol>
<li><p>开始他用区间$\ (0,1)\ $上的均匀分布$\ U(0,1)\ $作为$\ \theta\ $的先验分布。</p>
</li>
<li><p>后来觉得不妥，因为该产品的不合格率$\ \theta\ $比较小，不会超过$\ 0.5\%$，于是他改用区间$\ U(0,0.5)\ $作为$\ \theta\ $的先验分布</p>
</li>
<li><p>在一次业务会上，不少人对上限$\ 0.5\ $提出各种意见，有人觉得应该为$\ 0.1$，有人认为应该只是比$\ 0.5\ $小一点，应该取$\ 0.4$，但是对此他也没有把握。最后决策人提出以下看法：$\theta\ $的先验为$\ (0,\lambda)$，其中$\ \lambda\ $是超参数，要确切地定出$\ \lambda\ $是困难的，但是预示它的区间是有把握的。综合大家的意见，决策人最终认为$\ \lambda\ $是在区间$\ (0.1,0.5)\ $上的均匀分布$\ U(0.1,0.5)$。这后一个分布称为超先验。</p>
</li>
<li><p>我们归纳一下最终决定的先验：</p>
<ul>
<li>$\theta\ $的先验为$\ \pi_1(\theta|\lambda)=U(0,\lambda)$</li>
<li>$\lambda\ $的超先验为$\ \pi_2(\lambda)=U(0.1,0.5)$</li>
</ul>
<p>于是用边缘分布计算公式，可得$\ \theta\ $的先验为</p>
<script type="math/tex; mode=display">
\pi(\theta)=\int_\Lambda\pi_1(\theta|\lambda)\pi_2(\lambda)d\lambda</script><p>其中$\ \Lambda\ $是超参数$\ \lambda\ $的取值范围。在这个例子中：</p>
<script type="math/tex; mode=display">
\pi(\theta)=\frac{1}{0.5-0.1}\int_{0.1}^{0.5}\lambda \mathbb{I}_{(0,\lambda)}(\theta)d\lambda</script><p>其中$\ \mathbb{I}\ $为示性函数：</p>
<script type="math/tex; mode=display">
\mathbb{I}_{(0,\lambda)}(\theta)=\left\{
\begin{aligned}
1,\quad \theta\in\Lambda\\
0,\quad \theta\notin\Lambda
\end{aligned}
\right.</script></li>
</ol>
<p>理论上并没有限制多层先验只能有两层，可以是三步或更多步，但是在实际应用中多于两步的先验是很罕见的。对于第二层的超先验用主观概率或用历史数据给出是有困难的，因为$\ \lambda\ $常是不能观察的，甚至连间接观察都是难以进行的，所以用无信息先验作为超先验是一种好的策略。</p>
<p>多层先验常常是在这样一个场合使用，当一步给出先验$\ \pi(\theta)\ $没有把握时，那用二层先验要比硬用一层先验所冒的风险要小一些。</p>
<h4 id="多层模型"><a href="#多层模型" class="headerlink" title="多层模型"></a>多层模型</h4><p>(to be continued</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《贝叶斯统计》第2版  by 茆诗松，汤银才</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/04/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-2-%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/04/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-2-%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%8E%A8%E6%96%AD/" class="post-title-link" itemprop="url">贝叶斯统计 2 贝叶斯推断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-05-04 13:11:03" itemprop="dateCreated datePublished" datetime="2022-05-04T13:11:03+08:00">2022-05-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-07 15:31:02" itemprop="dateModified" datetime="2022-05-07T15:31:02+08:00">2022-05-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Bayesian-Statistics/" itemprop="url" rel="index"><span itemprop="name">Bayesian Statistics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="S-2-1-条件方法"><a href="#S-2-1-条件方法" class="headerlink" title="$\S 2.1\ $条件方法"></a><center>$\S 2.1\ $条件方法</center></h3><p>统计学中有一种重要的观点称为“条件观点”，即只考虑已出现的数据（样本观察值），而认为未出现的数据与推断无关。后验分布$\ \pi(\theta|\mathbf{x})\ $是在样本$\ \mathbf{x}\ $给定下$\ \theta\ $的条件分布，基于后验分布的统计推断就践行了这样的观点。我们将基于条件观点提出的统计推断方法称为条件方法。</p>
<h3 id="S-2-2-估计"><a href="#S-2-2-估计" class="headerlink" title="$\S 2.2\ $估计"></a><center>$\S 2.2\ $估计</center></h3><h4 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h4><p>设$\ \theta\ $是总体分布$\ p(x|\theta)$中的参数，为估计该参数可从总体中随机抽取一个样本$\ \mathbf{x}=(x_1,…,x_n)$，同时依据参数的先验信息选择一个先验分布（第三章将会讨论这个问题），用贝叶斯公式算得后验分布$\ \pi(\theta|\mathbf{x})\ $。最后，如果硬要我们拿出一个$\ \theta\ $的估计值出来，我们可以选用后验分布的某个位置特征值，如众数、中位数或者期望。</p>
<p>以下三个估计都成为$\ \theta\ $的贝叶斯估计：</p>
<ul>
<li>最大后验估计$\ \hat\theta_{MD}$：使后验密度$\ \pi(\theta|\mathbf{x})\ $达到最大值的$\ \theta$</li>
<li>后验中位数估计$\ \hat\theta_{Me}$：后验分布的中位数</li>
<li>后验期望估计$\ \hat\theta_{E}$：后验分布的期望值</li>
</ul>
<p>在这里提及以下事实：</p>
<ul>
<li>显然对于非对称后验分布，我们所得出来的估计量可能并不相同，在实际情况中需要再进行选择。而一条指导性意见是两个估计量在小样本上的解释性是否有哪个更优。</li>
<li>有时候我们所得的贝叶斯估计就是经典统计中的极大似然估计，例如在二项分布场合下，取特殊先验为均分分布的$\ \theta\ $，它的最大后验估计就是经典统计中的极大似然估计。贝叶斯学派对这种现象的看法是：任何使用经典统计的人都在自觉或者不自觉地使用贝叶斯推断，与其不自觉地使用，还不如主动选取更合适的先验分布使推断更富有意义。当然频率学派并不会接受这种观点，因为贝叶斯学派尚未证明：总体分布$\ p(x|\theta)\ $中参数的任一经典估计都存在一个先验分布，使得其贝叶斯估计就是该经典统计。</li>
</ul>
<p>更多更详细的内容请查阅参考文献《贝叶斯统计》第37至39页。</p>
<h4 id="贝叶斯估计的误差"><a href="#贝叶斯估计的误差" class="headerlink" title="贝叶斯估计的误差"></a>贝叶斯估计的误差</h4><p>在得到一个估计值之后，我们往往需要知道这个估计值究竟有多靠谱，能不能放心的在实际生活中进行使用，此时我们就需要考虑一个误差的问题了。而衡量误差很自然的想法就是利用方差或者是标准差，好在我们已经有关于参数$\ \theta\ $的后验分布，所以最好而又最简单的方法就是用$\ \theta\ $对$\ \hat\theta\ $的后验均方差或其平方根来度量。</p>
<p>设参数$\ \theta\ $的后验分布$\ \pi(\theta|\mathbf{x})\ $，贝叶斯估计为$\ \hat\theta\ $，则$\ (\theta-\hat\theta)^2\ $的后验期望</p>
<script type="math/tex; mode=display">
MSE(\hat\theta|\mathbf{x})=E^{\theta|\mathbf{x}}[(\theta-\hat\theta)^2]</script><p>称为$\ \hat\theta\ $的后验均方差，而其平方根$\ [MSE(\hat\theta|\mathbf{x})]^{1/2}\ $称为$\ \hat\theta\ $的后验标准误。其中符号$\ E^{\theta|\mathbf{x}}\ $表示用条件分布$\ \pi(\theta|\mathbf{x})\ $求期望。在连续情形下，有</p>
<script type="math/tex; mode=display">
E^{\theta|\mathbf{x}}[(\theta-\hat\theta)^2]=\int_{\Theta}(\theta-\hat\theta)^2\pi(\theta|\mathbf{x})d\theta</script><p>经过简单的推断，我们还可以得到后验均方差与后验均值之间的关系</p>
<script type="math/tex; mode=display">
MSE(\hat\theta|\mathbf{x})=Var(\theta|\mathbf{x})+(\hat\theta_E-\hat\theta)^2</script><p>其中$\ \hat\theta_E=E(\theta|\mathbf{x})$。</p>
<h3 id="S-2-3-区间估计"><a href="#S-2-3-区间估计" class="headerlink" title="$\S 2.3\ $区间估计"></a><center>$\S 2.3\ $区间估计</center></h3><p>由于贝叶斯学派将参数$\ \theta\ $视为随机变量，所以我们可以很自然的讨论关于$\ \theta\ $的区间估计问题。我们将这种区间称为贝叶斯可信区间。</p>
<p>而在经典统计中，我们也有类似的给出置信区间的结果。相比之下，置信区间就让人感觉有些摸不着头脑了。比如说我们在95%的置信水平下得到关于$\ \theta\ $的置信区间，此时我们并不允许说$\ \theta\ $落在此区间内的<strong>概率</strong>是0.95，因为对于非随机的常量$\ \theta$，我们并不能言及概率。事实上，给定一个置信区间，常量$\ \theta\ $要么落在置信区间内，要么不落在置信区间内，是一个确定性事件。我们只能以曲线救国的方式将置信区间视为<strong>随机置信区间</strong>说：“在100次使用这个置信区间时，大约有90次能盖住$\ \theta$。”而此种频率解释对仅使用一次或两次的人来说是毫无意义的。很多人还是会下意识将求得的置信区间当作可信区间去使用和理解。</p>
<p>设参数$\ \theta\ $的后验分布为$\ \pi(\theta|\mathbf{x})$，对于给定的样本$\ \mathbf{x}\ $和概率$\ 1-\alpha(0&lt;\alpha&lt;1)$，若存在这样的两个统计量$\ \hat\theta_L=\hat\theta_L(\mathbf{x})\ $与$\ \hat\theta_U=\hat\theta_U(\mathbf{x})$，使得</p>
<script type="math/tex; mode=display">
P(\hat\theta_L\le\theta\le\hat\theta_U|\mathbf{x})\ge 1-\alpha</script><p>则称区间$\ [\hat\theta_L,\hat\theta_U]\ $为参数$\ \theta\ $的可信水平为$\ 1-\alpha\ $（贝叶斯）可信区间。而满足</p>
<script type="math/tex; mode=display">
P(\theta\ge\hat\theta_L|\mathbf{x})\ge 1-\alpha</script><p>的$\ \hat\theta_L\ $称为$\ \theta\ $的$\ 1-\alpha$（单侧）可信下限。满足</p>
<script type="math/tex; mode=display">
P(\theta\le\hat\theta_U|\mathbf{x})\ge 1-\alpha</script><p>的$\ \hat\theta_U\ $称为$\ \theta\ $的$\ 1-\alpha$（单侧）可信上限。</p>
<ul>
<li><p>对给定的可信水平$\ 1-\alpha$，从后验分布$\ \pi(\theta|\mathbf{x})\ $获得的可信区间不止一个，常用的方法是用$\ \alpha/2\ $和$\ 1-\alpha/2\ $的分位数来获得$\ \theta\ $的可信区间。</p>
</li>
<li><p>等尾可信区间在实际中常常被使用，但并不是最理想的，最理想的可信区间应是区间长度最短。这只要把具有最大后验密度的点都包含在区间中，而在区间外的点上的后验密度函数值均不超过区间内的函数值。我们称这样的区间为最大后验密度（Highest Posterior Density，HPD）可信区间。</p>
</li>
</ul>
<h3 id="S-2-4-假设检验"><a href="#S-2-4-假设检验" class="headerlink" title="$\S 2.4\ $假设检验"></a><center>$\S 2.4\ $假设检验</center></h3><h4 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h4><p>考虑这样的假设检验问题：建立原假设$\ H_0\ $与备择假设$\ H_1\ $</p>
<script type="math/tex; mode=display">
H_0:\theta\in\Theta_0,\quad H_1:\theta\in\Theta_1</script><p>其中$\ \Theta_0\cap\Theta_1=\empty$。</p>
<p>在贝叶斯统计中处理假设检验问题是直截了当的，在获得后验分布$\ \pi(\theta|\mathbf{x})\ $后，即可计算两个假设$\ H_0\ $和$\ H_1\ $的后验概率</p>
<script type="math/tex; mode=display">
\alpha_i=P(\Theta_i|\mathbf{x})d\theta,\quad i=0,1</script><p>然后比较$\ \alpha_0\ $与$\ \alpha_1\ $的大小：</p>
<ul>
<li>当后验概率比（或称后验机会比）$\alpha_0/\alpha_1\gt 1$时接受$\ H_0\ $；</li>
<li>当后验概率比（或称后验机会比）$\alpha_0/\alpha_1\lt 1$时接受$\ H_1\ $；</li>
<li>当后验概率比（或称后验机会比）$\alpha_0/\alpha_1=1$时不做判断</li>
</ul>
<p>可以看到比起经典统计下的假设检验，我们并不需要选择检验统计量，确定抽样分布，也无需事先给定显著性水平，确定其拒绝域。</p>
<p>最后，当我们推广到多重假设检验场合时，应接受具有最大后验概率的假设。</p>
<h4 id="贝叶斯因子"><a href="#贝叶斯因子" class="headerlink" title="贝叶斯因子"></a>贝叶斯因子</h4><p>贝叶斯因子即是后验机会比/先验机会比</p>
<p>我们通过定义来感受一下贝叶斯因子究竟在干什么：</p>
<script type="math/tex; mode=display">
B_\pi(\mathbf{x})=\frac{后验机会比}{先验机会比}=\frac{\alpha_0/\alpha_1}{\pi_0\pi_1}=\frac{\alpha_0\pi_1}{\alpha_1\pi_0}</script><p>首先分子“后验机会比”已经将后验的信息进行很好的利用（这其中就包含了样本信息和先验信息），但是接着我们又将该值除以先验机会比。</p>
<p>刚开始接触这个概念时，我误以为贝叶斯因子是和后验机会比一样是用来判定假设检验的结果的。那么这就产生了一个很奇怪的问题了，我们看到贝叶斯因子既依赖于数据，又依赖于先验分布，对两种机会比相除，直观上这会削弱甚至（在某些情况下会）消除先验的影响。不过后来发现它并不是用来判定的……注意到贝叶斯因子减弱了先验的影响，突出了数据的影响，从这个角度看，贝叶斯因子是衡量了数据支持原假设的程度。</p>
<p>在简单假设$\ \Theta_0=\{\theta_0\}\ v.s.\Theta_1=\{\theta_1\}$下：</p>
<ul>
<li><p>两种简单假设的后验概率分别为</p>
<script type="math/tex; mode=display">
\alpha_0=\frac{\pi_0p(\mathbf{x}|\theta_0)}{\pi_0p(\mathbf{x}|\theta_0)+\pi_1p(\mathbf{x}|\theta_1)},\quad \alpha_1=\frac{\pi_1p(\mathbf{x}|\theta_1)}{\pi_0p(\mathbf{x}|\theta_0)+\pi_1p(\mathbf{x}|\theta_1)}</script></li>
<li><p>计算贝叶斯因子</p>
<script type="math/tex; mode=display">
B^\pi(\mathbf{x})=\frac{\alpha_0\pi_1}{\alpha_1\pi_0}=\frac{p(\mathbf{x}|\theta_0)}{p(\mathbf{x}|\theta_1)}</script><p>贝叶斯因子不依赖于先验分布，仅依赖于样本的似然比。这时贝叶斯因子的大小表示了样本$\ \mathbf{x}\ $支持$\ \Theta_0\ $的程度。</p>
</li>
</ul>
<p>在复杂假设下，贝叶斯因子虽然已经不是似然比了，但仍可以看成是原假设与备择假设的加权似然比，它平均的消除了先验分布的影响，而强调了样本观察值的作用。</p>
<p>在简单原假设对复杂的备择假设的场合下，例如很经典的检验问题$\ H_0=\theta_0\ v.s.H_1=\theta_1$。有别于前面问题的是不能采用连续密度函数作为先验分布，因为任何这种先验将给$\ \theta=\theta_0\ $的先验概率为0。基本的想法是赋予$\ \theta_0\ $一个正的概率，采用由离散和连续两部分组成的先验分布。</p>
<p>关于以上两个场合的假设检验问题更加详细的内容，感兴趣的同学请参看《贝叶斯统计》P54~63。</p>
<h3 id="S-2-5-预测"><a href="#S-2-5-预测" class="headerlink" title="$\S 2.5\ $预测"></a><center>$\S 2.5\ $预测</center></h3><p>对随机变量未来观察值作出统计推断称为预测，譬如：</p>
<ol>
<li>设随机变量$\ X\sim p(x|\theta)$，在参数$\ \theta\ $未知情况下如何对$\ X\ $的未来的观察值作出推断</li>
<li>设$\ x_1,…x_n\ $是来自$\ p(x|\theta)\ $​的过去观察值，在参数$\ \theta\ $未知情况下如何对$\ X\ $的未来的观察值作出推断</li>
<li>按密度函数$\ p(x|\theta)\ $得到一些数据$\ x_1,…x_n\ $后，如何对具有密度函数$\ g(z|\theta)\ $的随机变量$\ Z\ $的未来的观察值作出推断，这里第二个密度函数$\ p\ $和$\ g\ $都含有相同的未知参数$\ \theta$。</li>
</ol>
<p>在贝叶斯统计中，由于参数$\ \theta\ $随机且不可观测，我们的想法就是利用$\ \theta\ $的先验分布或者后验分布综合地考虑所有$\ \theta\ $的可能取值。共同点都是要获得预测分布。</p>
<ol>
<li><p>设随机变量$\ X\sim p(x|\theta)$，在无$\ X\ $的观察数据时，利用先验分布$\ \pi(\theta)\ $得到未知的但可以观测的数据$\ x\ $的分布</p>
<script type="math/tex; mode=display">
m(x)=\int_\Theta p(x|\theta)\pi(\theta)d\theta</script><p>这个分布常被称为$\ X\ $的边缘分布，但它还有一个更富有内涵的名称是“先验预测分布”。有了预测分布之后，我们就可以根据所需例如取期望值、中位数或众数作为预测值，也可以类似可信区间的形式取得预测区间。</p>
</li>
<li><p>在有$\ X\ $的观察数据$\ \mathbf{x}=(x_1,…,x_n)\ $时，改用后验分布$\pi(\theta|\mathbf{x})\ $获得“后验预测分布”</p>
<script type="math/tex; mode=display">
m(x|\mathbf{x})=\int_\Theta p(x|\theta)\pi(\theta|\mathbf{x})d\theta</script><p>也可以预测另一个总体$\ g(z|\theta)\ $的未来观察值，只要考虑如下分布：</p>
<script type="math/tex; mode=display">
m(z|\mathbf{x})=\int_\Theta g(z|\theta)\pi(\theta|\mathbf{x})d\theta</script></li>
</ol>
<h3 id="S-2-6-似然原理"><a href="#S-2-6-似然原理" class="headerlink" title="$\S 2.6\ $似然原理"></a><center>$\S 2.6\ $似然原理</center></h3><p>似然原理的核心概念是似然函数，对似然函数理解大家都是一致的，若设$\ \mathbf{x}=(x_1,…,x_n)\ $是来自密度函数$\ p(x|\theta)\ $的一个样本，则其乘积</p>
<script type="math/tex; mode=display">
p(\mathbf{x}|\theta)=\prod_{i=1}^{n}p(x_i|\theta)</script><p>有两个解释：当$\ \theta\ $给定时，$p(\mathbf{x}|\theta)\ $时样本$\ \mathbf{x}\ $的联合密度函数，当样本$\ \mathbf{x}\ $的观察值给定时，$p(\mathbf{x}|\theta)\ $是未知参数$\ \theta\ $的函数，并称为似然函数，记为$\ L(\theta)$。</p>
<p>似然函数$\ L(\theta)\ $强调：它是$\ \theta\ $的函数，而样本$\ \mathbf{x}\ $在似然函数中只是一组数据或一组观察值。所有与试验有关的$\ \theta\ $的信息都被包含在似然函数之中，使$\ L(\theta)=p(\mathbf{x}|\theta)\ $大的$\ \theta\ $比使使$\ L(\theta)\ $小的$\ \theta\ $更像是$\ \theta\ $的真值。特别地，使$\ L(\theta)\ $在参数空间中$\ \Theta\ $达到最大的$\ \hat\theta\ $称为极大似然估计。</p>
<p>（好吧，其实我也没太看得懂上一段在说什么……我还是用自己的话解释一遍吧……（当然如果你看懂了上面在说什么，那就不用浪费时间再听我的废话了</p>
<blockquote>
<p>首先，我们接着上面的两种解释继续说：当$\ \theta\ $给定时，$p(\mathbf{x}|\theta)\ $时样本$\ \mathbf{x}\ $的联合密度函数，它表示了某个样本观察值在参数已知的情况下发生的概率；而当我们对总体进行观测得到样本时（给定样本观察值），此时对于$\ p(\mathbf{x}|\theta)\ $就不能言及概率了，它随着未知参数$\ \theta$的变动而变动。</p>
<p>而极大似然估计的想法就是认为最先出现的样本是最有可能的发生的。基于这个想法，我们希望变动$\ \theta\ $使得，对这个固定的$\ \theta$（看第一个解释）样本观察值发生概率，即似然函数达到最大。</p>
<p>Emmmm…感觉我解释得也挺糟糕的…哎不管了…</p>
</blockquote>
<p>似然原理有如下两点：</p>
<ol>
<li>有了观测值$\ \mathbf{x}\ $之后，在做关于$\ \theta\ $的推断和决策时，所有与试验有关的$\ \theta\ $信息均被包含在似然函数$\ L(\theta)\ $中。</li>
<li>如果有两个似然函数是成比例的，比例常数与$\ \theta\ $无关，则它们关于$\ \theta\ $含有相同的信息。</li>
</ol>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《贝叶斯统计》第2版  by 茆诗松，汤银才</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-1-%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E4%B8%8E%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/30/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1-1-%E5%85%88%E9%AA%8C%E5%88%86%E5%B8%83%E4%B8%8E%E5%90%8E%E9%AA%8C%E5%88%86%E5%B8%83/" class="post-title-link" itemprop="url">贝叶斯统计 1 先验分布与后验分布</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-30 10:42:06" itemprop="dateCreated datePublished" datetime="2022-04-30T10:42:06+08:00">2022-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-05 13:17:43" itemprop="dateModified" datetime="2022-05-05T13:17:43+08:00">2022-05-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Bayesian-Statistics/" itemprop="url" rel="index"><span itemprop="name">Bayesian Statistics</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>统计学中主要有两个学派：频率学派与贝叶斯学派。要说清楚它们之间的关系，我们先从统计推断中的三种信息说起。</p>
<h3 id="S-1-1-三种信息"><a href="#S-1-1-三种信息" class="headerlink" title="$\S 1.1\ $三种信息"></a><center>$\S 1.1\ $三种信息</center></h3><h4 id="总体信息"><a href="#总体信息" class="headerlink" title="总体信息"></a>总体信息</h4><p>总体信息即是总体分布或总体所属分布族给我们的信息。总体信息是很重要的，但是为了获取这种信息往往耗资巨大。</p>
<h4 id="样本信息"><a href="#样本信息" class="headerlink" title="样本信息"></a>样本信息</h4><p>样本信息即从总体抽取的样本给我们的提供的信息。人们希望通过样本信息对总体的某些特征进行较为精确的统计推断。没有样本就没有统计学可言。</p>
<h4 id="先验信息"><a href="#先验信息" class="headerlink" title="先验信息"></a>先验信息</h4><p>先验信息是在抽样之前有关统计问题的一些信息，一般来说，先验信息主要来源于经验和历史资料。很显然，成熟而靠谱的经验有助于我们得到更加精确的结论。例如一个常饮牛奶加茶的女士声称她能辨别出先倒进杯子的究竟是牛奶还是茶。对此统计学家做了十次试验，结果发现她每次都正确说出来了。而当无知的统计学家妄自尊大地想自己去尝试辨别（盲猜）时，却只成功猜中了4次。在这种情况下，我们确实看到了经验对于推断产生的影响。</p>
<p>基于上述三种信息进行的统计推断称为贝叶斯统计学。它与经典的统计学的主要差别在于是否利用先验信息。另外，它们在使用样本信息上也是有差别的。贝叶斯学派重视已出现的样本观察值，而对尚未发生的样本观察值不予考虑。贝叶斯学派很重视先验信息的收集、挖掘和加工，使它数量化，形成先验分布，参加到统计推断中来，以提高统计推断的质量。</p>
<p>更具体地说，贝叶斯学派的最基本的观点就是：任一个未知量$\ \theta\ $都可以看作一个随机变量，应用一个概率分布去描述对$\ \theta\ $的未知情况。当然这个分布在未进行抽样之前就已经给出了，所以也被称为先验分布，或简称先验（prior）。而频率学派则认为$\ \theta\ $是一个常量，并不存在任何的不确定性。</p>
<h3 id="S-1-2-贝叶斯公式"><a href="#S-1-2-贝叶斯公式" class="headerlink" title="$\S 1.2\ $贝叶斯公式"></a><center>$\S 1.2\ $贝叶斯公式</center></h3><h4 id="贝叶斯公式的密度函数形式"><a href="#贝叶斯公式的密度函数形式" class="headerlink" title="贝叶斯公式的密度函数形式"></a>贝叶斯公式的密度函数形式</h4><ol>
<li><p>依赖于参数$\ \theta\ $的密度函数在经典统计中记为$p(x;\theta)$或者$p_\theta(x)$，它表示在参数空间$\Theta=\{\theta\}$中不同的$\ \theta\ $对应的不同的分布。可在贝叶斯统计中记为$\ p(x|\theta)$，它表示在随机变量给定某个值时，总体指标$\ X\ $的条件分布。</p>
</li>
<li><p>根据参数$\ \theta\ $的先验信息确定先验分布$\ \pi(\theta)\ $。</p>
</li>
<li><p>从贝叶斯观点看，样本$\ \mathbf{x}=(x_1,…,x_n)\ $的产生要分二步进行：</p>
<ul>
<li><p>首先设想从先验分布$\ \pi(\theta)\ $产生一个样本$\ \theta’\ $，这一步是人们看不到的；</p>
</li>
<li><p>第二步是从总体分布$\ p(x|\theta)\ $产生一个样本$\ \mathbf{x}=(x_1,…,x_n)\ $，这个样本是具体的，是人们能看得到的。此样本的$\ \vec{x}\ $发生的概率是与如下联合密度函数成正比</p>
<script type="math/tex; mode=display">
p(\mathbf{x}|\theta')=\prod_{i=1}^{n}p(x_i|\theta')</script><p>这个联合密度函数综合了<strong>总体信息</strong>和<strong>样本信息</strong>，常称为似然函数，记为$\ L(\theta’)$。在有了样本观察值之后，总体和样本信息中所含$\ \theta \ $的信息都被包含在似然函数$\ L(\theta’)\ $中。</p>
</li>
</ul>
</li>
<li><p>由于$\ \theta’\ $是由先验分布$\ \pi(\theta)\ $随机产生的，所以我们要利用<strong>先验信息</strong>把$\ \theta\ $所有可能的取值加以考虑。我们考虑样本和参数$\ \theta\ $的联合分布</p>
<script type="math/tex; mode=display">
h(\mathbf{x},\theta)=p(\mathbf{x}|\theta)\pi(\theta)</script><p>这样我们就把三种可用的信息都综合进去了。</p>
</li>
<li><p>我们的任务是对未知数$\ \theta\ $作出统计推断。在没有样本信息时，人们只能根据先验分布对$\ \theta\ $作出推断。在得到样本观察值$\ \mathbf{x}=(x_1,…,x_n)\ $之后，我们根据三种信息的综合$\ h(x,\theta)\ $对$\ \theta\ $作出推断。为此我们把$\ h(x,\theta)\ $进行如下分解：</p>
<script type="math/tex; mode=display">
h(\mathbf{x},\theta)=\pi(\theta|\mathbf{x})m(\mathbf{x})</script><p>其中$\ m(\mathbf{x})\ $是$\ \mathbf{x}\ $的边缘密度函数（$\ m(\mathbf{x})\ $还有其他的含义，我们将在第三章提及）：</p>
<script type="math/tex; mode=display">
m(\mathbf{x})=\int_{\Theta}h(\mathbf{x},\theta)d\theta=\int_{\Theta}p(\mathbf{x}|\theta)\pi(\theta)</script><p>为得到关于$\ \mathbf{x}\ $的边缘密度函数，我们已经对$\ \theta\ $进行了积分，此时它与$\ \theta\ $无关，或者说$\ m(\mathbf{x})\ $中不包含$\ \theta\ $的任何信息。因此能用来对$\ \theta\ $进行推断的仅仅是条件分布$\ \pi(\theta|\mathbf{x})$。它的计算公式如下所示：</p>
<script type="math/tex; mode=display">
\pi(\theta|\mathbf{x})=\frac{h(\mathbf{x},\theta)}{m(\mathbf{x})}=\frac{p(\mathbf{x}|\theta)\pi(\theta)}{\int_{\Theta}p(\mathbf{x}|\theta)\pi(\theta)d\theta}</script><p>这就是贝叶斯公式的密度函数形式。这个在样本$\ \mathbf{x}\ $给给定下，$\ \theta\ $的条件分布被称为$\ \theta\ $的后验愤分布。它是集中了总体、样本、先验这三种信息中有关$\ \theta\ $的一切信息，而又是派出了一切与$\ \theta\ $无关的信息之后所得到的结果。</p>
</li>
<li><p>在离散情况下，先验分布可用先验分布列$\ \pi(\theta_i)\ $表示。此时后验分布也是离散形式：</p>
<script type="math/tex; mode=display">
\pi(\theta_i|\mathbf{x})=\frac{p(\mathbf{x}|\theta_i)\pi(\theta_i)}{\sum_jp(\mathbf{x}|\theta_j)\pi(\theta_j)},\quad i=1,2,...</script></li>
</ol>
<h4 id="后验分布是三种信息的综合"><a href="#后验分布是三种信息的综合" class="headerlink" title="后验分布是三种信息的综合"></a>后验分布是三种信息的综合</h4><p>一般来说，先验分布$\ \pi(\theta)\ $是反映人们在抽样之前对$\ \theta\ $的认识，后验分布$\ \pi(\theta|\mathbf{x})$则是反映了人们在抽样之后对$\ \theta\ $的认识。两者的差异是由于样本$\ \mathbf{x}\ $出现后（获得总体信息和样本信息）人们对$\ \theta\ $认识（先验信息）的一种调整。</p>
<h3 id="S-1-3-共轭先验分布"><a href="#S-1-3-共轭先验分布" class="headerlink" title="$\S 1.3\ $共轭先验分布"></a><center>$\S 1.3\ $共轭先验分布</center></h3><h4 id="共轭先验分布"><a href="#共轭先验分布" class="headerlink" title="共轭先验分布"></a>共轭先验分布</h4><p>共轭先验分布想法的产生源于我们希望先验分布和后验分布能具有某种一样的函数形式（它们可能会依赖于某些<strong>超参数</strong>，即先验分布中所含的未知参数），而随着新样本信息的获得，我们可以在同一个分布函数形式框架下仅通过超参数的改变就能更新后验分布，这将给我们的计算带来很大的便利。</p>
<p>可以想象到这是一种“实时驱动型”的迭代更新方式，每当有一个新样本出现，我们就可以将上一次更新后的后验分布视为先验分布，再进行一次参数更新，如此进行下去。</p>
<p>我们给共轭先验一个文字性的定义：设$\ \theta\ $是总体分布中的参数（或参数向量），$\ \pi(\theta)\ $是$\ \theta\ $的先验密度函数，假如由抽样信息算得的后验密度函数与$\ \pi(\theta)\ $有相同的函数形式，则称$\ \pi(\theta)\ $是$\ \theta\ $的（自然）共轭先验分布。</p>
<h4 id="后验分布的计算"><a href="#后验分布的计算" class="headerlink" title="后验分布的计算"></a>后验分布的计算</h4><p>经由$\ \S 1.2\ $的分析，我们已经知道了后验分布可以通过以下方式进行计算：</p>
<script type="math/tex; mode=display">
\pi(\theta|\mathbf{x})=\frac{h(\mathbf{x},\theta)}{m(\mathbf{x})}=\frac{p(\mathbf{x}|\theta)\pi(\theta)}{m(\mathbf{x})}</script><p>在实际计算过程中，由于我们计算的是密度函数，另外$\ m(\mathbf{x})\ $与$\ \theta\ $无关，仅仅是充当正则化因子（使得计算结果确实是一个密度函数），所以我们仅需考虑后验分布的核的函数形式：</p>
<script type="math/tex; mode=display">
\pi(\theta|\mathbf{x})\propto p(\mathbf{x}|\theta)\pi(\theta)</script><p>另外我们再稍微想一想：首先我们将$\ p(\mathbf{x}|\theta)\pi(\theta)\ $改写成如下形式：</p>
<script type="math/tex; mode=display">
\pi(\theta|\mathbf{x})\propto \prod_{i=1}^{n}p(x_i|\theta)\pi(\theta)</script><p>注意到$\ \prod_{i=1}^{n}p(x_i|\theta)\ $是我们所熟悉的似然函数，我们若要使先验和后验分布具有同样的形式，似然函数中参数的函数形式可能会给共轭先验的构造提供给一些思路。</p>
<h4 id="共轭先验分布的优缺点"><a href="#共轭先验分布的优缺点" class="headerlink" title="共轭先验分布的优缺点"></a>共轭先验分布的优缺点</h4><p>优点是显而易见的：</p>
<ul>
<li>计算方便</li>
<li>后验分布的一些参数能够得到很好的解释</li>
</ul>
<p>缺点：</p>
<ul>
<li>先验分布必须具有一定的合理性，否则强行使用共轭先验很可能会掩盖实际情况</li>
</ul>
<h4 id="常用的共轭先验分布"><a href="#常用的共轭先验分布" class="headerlink" title="常用的共轭先验分布"></a>常用的共轭先验分布</h4><p>共轭先验分布的选取是由似然函数$\ L(\theta)=p(\mathbf{x}|\theta)\ $中所含$\ \theta\ $的因式所决定的，即选与似然函数（$\ \theta\ $的函数）具有相同核的分布作为先验分布。若此想法得以实现，那么共轭先验分布就产生了。而似然函数又与总体分布的形式有着某些关联。在下表中，我们列出了在实际中常用的共轭先验分布：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">总体分布</th>
<th style="text-align:center">参数</th>
<th style="text-align:center">共轭先验分布</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">二项分布</td>
<td style="text-align:center">成功概率</td>
<td style="text-align:center">贝塔分布$\ Be(\alpha,\beta)$</td>
</tr>
<tr>
<td style="text-align:center">泊松分布</td>
<td style="text-align:center">均值</td>
<td style="text-align:center">伽马分布$\ Ga(\alpha,\lambda)$</td>
</tr>
<tr>
<td style="text-align:center">指数分布</td>
<td style="text-align:center">均值的倒数</td>
<td style="text-align:center">伽马分布$\ Ga(\alpha,\lambda)$</td>
</tr>
<tr>
<td style="text-align:center">正态分布（方差已知）</td>
<td style="text-align:center">均值</td>
<td style="text-align:center">正态分布$\ N(\mu,\sigma^2)$</td>
</tr>
<tr>
<td style="text-align:center">正态分布（均值已知）</td>
<td style="text-align:center">方差</td>
<td style="text-align:center">倒伽马分布$\ IGa(\alpha,\lambda)$</td>
</tr>
</tbody>
</table>
</div>
<h3 id="S-1-4-超参数及其确定"><a href="#S-1-4-超参数及其确定" class="headerlink" title="$\S 1.4\ $超参数及其确定"></a><center>$\S 1.4\ $超参数及其确定</center></h3><p>前面我们已经提到过超参数这个概念了。其实超参数的定义非常简单，就是先验分布中所含的未知参数。（看到这个定义时我们很容易产生一个自然的想法：如果参数可以是随机的，那么超参数是不是可以是随机的并服从一个先验分布。当然，这种想法是没有任何问题的，并且这在贝叶斯统计中称为多层先验——我们将在第三章再进行介绍。）</p>
<p>一般来说，共轭先验分布常含有超参数，而无信息先验分布一般不含有超参数，例如均分分布（等概率的取值表示大自然对参数的取值并没有任何偏好）。</p>
<p>共轭先验分布是一种有信息的先验分布，故其中所含的超参数应充分利用各种先验信息来进行确定。</p>
<p>如果以二项分布为例，二项分布成功概率$\ \theta\ $的共轭先验分布是贝塔分布$\ Be(\alpha,\beta)$，$\alpha,\beta\ $是超参数。我们可以通过以下几种方法进行超参数的确定：</p>
<ol>
<li>利用先验矩</li>
<li>利用先验分位数</li>
<li>利用先验矩和先验分位数</li>
<li>其他方法</li>
</ol>
<p>详细过程不予赘述，如果感兴趣的话可以直接阅读茆诗松所著《贝叶斯统计》第2版的P20~23或是相关的文献。</p>
<h3 id="S-1-5-多参数模型"><a href="#S-1-5-多参数模型" class="headerlink" title="$\S 1.5\ $多参数模型"></a><center>$\S 1.5\ $多参数模型</center></h3><h3 id="S-1-6-充分统计量"><a href="#S-1-6-充分统计量" class="headerlink" title="$\S 1.6\ $充分统计量"></a><center>$\S 1.6\ $充分统计量</center></h3><h4 id="充分统计量"><a href="#充分统计量" class="headerlink" title="充分统计量"></a>充分统计量</h4><p>在简化统计问题中，充分统计量是一个非常重要的概念。（回顾一下什么叫做统计量：一个仅有样本决定，而与参数无关的量，也即当我获得样本的观察值时，统计量的值也随之确定）</p>
<p>引入充分统计量的想法如下：首先我们需要认识到样本是我们进行一切统计推断的基础，它提供了我们进行统计推断的一切“证据”（或者说信息），所以没有样本就没有统计推断。而统计量是我们对样本进行的信息加工和处理。在加工的过程中，统计量所含的信息必定只减不增。而所谓充分性则是说我们在这个加工过程中应该要能把包含未知参数的全部信息都提取出来。</p>
<p>用数学语言来描述这件事情（经典统计中的充分统计量）可能就稍微难以理解一点：设$\ \mathbf{x}=(x_1,…,x_n)\ $是来自分布函数$\ F(x|\theta)\ $的一个样本，$\ T=T(\mathbf{x})\ $是统计量。假如在给定$\ T(\mathbf{x})=t\ $的条件下，$\ x\ $的条件分布与$\ \theta\ $无关，则称该统计量为$\ \theta\ $的充分统计量。</p>
<p>一般情况下，直接运用定义进行验证一个统计量的充分性是困难的，所幸我们有因子分解定理保证这种充分性的充要条件。</p>
<h4 id="因子分解定理"><a href="#因子分解定理" class="headerlink" title="因子分解定理"></a>因子分解定理</h4><p>一个统计量$\ T(\mathbf{x})\ $对参数$\ \theta\ $是充分的充要条件是存在一个$\ t\ $与$\ \theta\ $的函数$\ g(t,\theta)\ $和一个样本$\ \mathbf{x}\ $的函数$\ h(\mathbf{x})$，使得对任一样本$\ \mathbf{x}\ $和任意$\ \theta$，样本的联合密度$\ p(\mathbf{x}, \theta)\ $可表为它们的乘积，即</p>
<script type="math/tex; mode=display">
p(\mathbf{x}|\theta)=g(T(\mathbf{x}),\theta)h(\mathbf{x})</script><p>在贝叶斯统计中，充分统计量也有一个充要条件：设$\ \mathbf{x}=(x_1,…,x_n)\ $是来自密度函数$\ p(x|\theta)\ $的一个样本，$\ T=T(\mathbf{x})\ $是统计量，它的密度函数为$\ p(t|\theta)$，又设$\ \mathscr{H}=\{\pi(\theta)\}\ $是$\ \theta\ $的某个先验分布族，则$\ T(\mathbf{x})\ $为$\ \theta\ $的充分统计量的充要条件是对任一先验分布$\ \pi(\theta)\in\mathscr{H}$，有</p>
<script type="math/tex; mode=display">
\pi(\theta|T(\mathbf{x}))=\pi(\theta|\mathbf{x})</script><p>即用样本分布$\ p(\mathbf{x}|\theta)\ $算得的后验分布与<strong>统计量$\ T(\mathbf{x})\ $算得的后验分布</strong>（可能达到简化计算的目的）是相同的。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>《贝叶斯统计》第2版  by 茆诗松，汤银才</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/17/Fundamentals-of-Unconstrained-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/17/Fundamentals-of-Unconstrained-Optimization/" class="post-title-link" itemprop="url">Fundamentals of Unconstrained Optimization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-17 08:59:10" itemprop="dateCreated datePublished" datetime="2022-04-17T08:59:10+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-05-08 15:59:47" itemprop="dateModified" datetime="2022-05-08T15:59:47+08:00">2022-05-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Numerical-Optimization/" itemprop="url" rel="index"><span itemprop="name">Numerical Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h3><p>Reminded that the general form of the optimization problem is as follows</p>
<script type="math/tex; mode=display">
\min_{x\in\R^n} f(x)\quad s.t.\
\begin{cases}
c_i(x)=0\quad i \in \mathcal{E}\\
c_i(x)\ge 0\quad i \in \mathcal{I}
\end{cases}</script><p>Now in unconstrained optimization, we minimize an objective function that depends on real variables, with no restrictions at all on the values of these variables. The mathematical formulation is</p>
<script type="math/tex; mode=display">
\min_{x\in\R^n}f(x)</script><p>where $\ x\in\R^n\ $ is a real vector with $\ n\ge 1\ $ components and $\ f:\R^n\rightarrow\R\ $ is a smooth function.</p>
<h3 id="What-Is-A-Solution"><a href="#What-Is-A-Solution" class="headerlink" title="What Is A Solution"></a>What Is A Solution</h3><h4 id="global-minimizer"><a href="#global-minimizer" class="headerlink" title="global minimizer"></a>global minimizer</h4><p>We say a point $\ x^{*}\ $ is a global minimizer if </p>
<script type="math/tex; mode=display">
f(x^*)\le f(x)\quad for\ all\ x\in\R^n</script><h4 id="local-minimizer"><a href="#local-minimizer" class="headerlink" title="local minimizer"></a>local minimizer</h4><p>Then a local minimizer is that the point is only achieves the smallest value of f in its neighborhood. Formally, we say a point $\ x^{*}\ $ is a local minimizer if there is a neighborhood $\ \mathcal{N}\ $ of $\ x^{*}\ $ such that  </p>
<script type="math/tex; mode=display">
f(x^*)\le f(x)\quad for\ all\ x\in\mathcal{N}</script><p>A point that satisfies this definition is sometimes called a weak local minimizer. A strict local minimizer is then the outright winner in its neighborhood. Formally, A point $\ x^{*}\ $ is a strict local minimizer</p>
<script type="math/tex; mode=display">
\exist\ \mathcal{N}\ s.t.\ f(x^{*})\lt f(x),\ \forall x\in\mathcal{N}\ \text{with}\ x\ne x^{*}</script><p>The last type of minimizer is called an isolated minimizer, which there is a neighborhood$\ \mathcal{N}\ $of$\ x^{*}\ $such that$\ x^{*}\ $is the only local minimizer in$\ \mathcal{N}\ $.</p>
<p>All isolated local minimizers are strict, while the reverse does not hold.</p>
<h3 id="Recognizing-A-Local-Minimum"><a href="#Recognizing-A-Local-Minimum" class="headerlink" title="Recognizing A Local Minimum"></a>Recognizing A Local Minimum</h3><p>It seems that we have to check all the points to make sure none of them has a smaller function value then as $\ x^{*}$’s did. Fortunately, supposing the objective function to be twice continuously differentiable, we may be able to tell that whether $\ x^{*}\ $is a local minimizer by examining just the gradient $\ \triangledown f(x^{*})\ $and the Hessian matrix $\ \triangledown^2 f(x^{*})$.</p>
<h4 id="Theorem-Taylor’s-Theorem"><a href="#Theorem-Taylor’s-Theorem" class="headerlink" title="Theorem (Taylor’s Theorem)"></a>Theorem (Taylor’s Theorem)</h4><p>suppose that $\ f:\R^n\rightarrow\R\ $is continuously differentiable and that $p \in \R^n$. Then we have that </p>
<script type="math/tex; mode=display">
f(x+p)=f(x)+\triangledown f(x+tp)^{T}p</script><p>for some $t\in (0,1)$. Moreover, if f is twice continuously differentiable, we have that </p>
<script type="math/tex; mode=display">
\triangledown f(x+p)=\triangledown f(x) + \int_{0}^{1}\triangledown^2f(x+tp)pdt</script><p>and that </p>
<script type="math/tex; mode=display">
f(x+p)=f(x)+\triangledown f(x)^{T}p+\frac 1{2}p^T\triangledown^2f(x+tp)p</script><p>for some $t\in (0,1)$.</p>
<h4 id="Theorem-First-Order-Necessary-Conditions"><a href="#Theorem-First-Order-Necessary-Conditions" class="headerlink" title="Theorem (First-Order Necessary Conditions)"></a>Theorem (First-Order Necessary Conditions)</h4><p>If $\ x^{*}\ $ is local minimizer and f is continuously differentiable in an open neighborhood of $\ x^{*}\ $, then $\ \triangledown f(x^{*})=0$.</p>
<h4 id="Theorem-Second-Order-Necessary-Conditions"><a href="#Theorem-Second-Order-Necessary-Conditions" class="headerlink" title="Theorem (Second-Order Necessary Conditions)"></a>Theorem (Second-Order Necessary Conditions)</h4><p>If $\ x^{*}\ $is a local minimizer of f and $\ \triangledown^2f\ $ exists and is continuous in an open neighborhood of $\ x^{*}\ $, then $\ \triangledown f(x^{*})=0\ $and $\ \triangledown^2 f(x^{*})\ $is positive semidefinite.</p>
<h4 id="Theorem-Second-Order-Sufficient-Conditions"><a href="#Theorem-Second-Order-Sufficient-Conditions" class="headerlink" title="Theorem (Second-Order Sufficient Conditions)"></a>Theorem (Second-Order Sufficient Conditions)</h4><p>Suppose that  $\ \triangledown^2f\ $ is continuous in an open neighborhood of $\ x^{*}\ $, and that $\ \triangledown f(x^{*})=0\ $and $\ \triangledown^2 f(x^{*})\ $is positive definite. Then $\ x^{*}\ $ is a strict local minimizer of f.</p>
<h4 id="Theorem-Transformation-from-local-m-to-global-m"><a href="#Theorem-Transformation-from-local-m-to-global-m" class="headerlink" title="Theorem (Transformation from local-m to global-m)"></a>Theorem (Transformation from local-m to global-m)</h4><p>When f is convex, any local minimizer $\ x^{*}\ $is a global minimizer of f. If in addition f is differentiable, then any stationary point $\ x^{*}\ $is a global minimizer of f.</p>
<h3 id="Overview-of-Algorithm"><a href="#Overview-of-Algorithm" class="headerlink" title="Overview of Algorithm"></a>Overview of Algorithm</h3><p>Our idea is simple. Beginning at a starting point $\ x_0$, optimization algorithms generate a sequence of iterates $\ \{x_k\}_{k=0}^{\infty}\ $ that terminate when either no more progress can be made or when it seems that a solution point has been approximated by current point $\ x_k\ $with sufficient accuracy.</p>
<p>Intuitively, when we generate such a sequence of iterates, we hope that the corresponding function value sequence $\ \{f(x_k)\}_{k=0}^{\infty}\ $ ought to decease (if we try to solve a minimization problem, otherwise to increase when facing a maximization problem) or at least we can decrease the objective function value $\ f(x_k)\ $ with several steps of iteration, that is $\ f(x_k)\lt f(x_{k-m})$.</p>
<p>There are two fundamental strategies for moving from the current point $\ x_k\ $to a new iterate $\ x_{k+1}$. Most of the algorithms describe in this book follow one of these approaches.</p>
<h4 id="two-strategies-line-search-and-trust-region"><a href="#two-strategies-line-search-and-trust-region" class="headerlink" title="two strategies: line search and trust region"></a>two strategies: line search and trust region</h4><h4 id="line-search"><a href="#line-search" class="headerlink" title="line search"></a>line search</h4><p>In the <strong>line search</strong> strategy, the algorithm chooses a <strong>direction</strong> $\ p_k\ $and searches along this direction from the current iterate $\ x_k\ $for a new iterate with a lower function value. The distance to move along $\ p_k\ $can be found by approximately solving the following one dimensional minimization problem to find a <strong>step length</strong> $\ \alpha$:</p>
<script type="math/tex; mode=display">
\min_{\alpha\gt 0}f(x_k+\alpha p_k)</script><p>By solving the problem above exactly, we would derive the maximum benefit from the direction $\ p_k$, but an exact minimization may be expensive. Instead, the line search algorithm generates a limited number of trial step lengths until it finds one that loosely approximates the minimum of the problem above.</p>
<h4 id="trust-region"><a href="#trust-region" class="headerlink" title="trust region"></a>trust region</h4><p>In the second algorithmic strategy, known as trust region, the information gathered about f is used to construct a model function $\ m_k\ $whose behavior near the current point $\ x_k\ $is similar to that of the actual objective function f. Because the model $\ m_k\ $may be a good approximation of f when x is far from $\ x_k$. In other words, we restrict the search for a minimizer of $\ m_k\ $to some region around $\ x_k$. In other words, we find the candidate step p by approximately solving the following subproblem:</p>
<script type="math/tex; mode=display">
\min_{p}m_k(x_k+p),\quad wherex_k+p\ lies\ inside\ the\ trust\ region</script><p>If the candidates solution does not produce a sufficient decrease in f, we conclude that the trust region is too large, and we shrink it and re-solve the problem.</p>
<p>The model $\ m_k\ $in the problem above is usually defined to be a quadratic function of the form </p>
<script type="math/tex; mode=display">
m_k(x_k+p)=f_k+p^T\triangledown f_k+\frac1{2}p^TB_kp</script><p>where $\ f_k$, $\triangledown f_k$, and $B_k\ $are scalar, vector, and matrix, respectively. The matrix $\ B_k\ $is either the Hessian $\ \triangledown^2f_k\ $or some approximation to it.</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Numerical Optimization (2nd) by Jorge Nocedal, Stephen J. Wright</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/15/Introduction-to-Numerical-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/15/Introduction-to-Numerical-Optimization/" class="post-title-link" itemprop="url">Introduction to Numerical Optimization</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-04-15 20:17:03" itemprop="dateCreated datePublished" datetime="2022-04-15T20:17:03+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-30 10:53:08" itemprop="dateModified" datetime="2022-04-30T10:53:08+08:00">2022-04-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Numerical-Optimization/" itemprop="url" rel="index"><span itemprop="name">Numerical Optimization</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Optimization"><a href="#Optimization" class="headerlink" title="Optimization"></a>Optimization</h3><p>Our goals is to find values of the variables that optimize the objectives. Often the variables are restricted, or constrained, in some way.</p>
<p>There is no universal optimization algorithm but rather a collection of algorithms, each of which is tailored to a particular type of optimization problem.</p>
<ul>
<li>optimality conditions: checking that the current set of variables is indeed the solution of the problem</li>
<li>sensitivity analysis: reveals the sensitivity of the solution to changes in the model and data.</li>
</ul>
<h3 id="Mathematical-Formulation"><a href="#Mathematical-Formulation" class="headerlink" title="Mathematical Formulation"></a>Mathematical Formulation</h3><p>We introduce some notations first:</p>
<ul>
<li>x is the vector of variables, also called unknowns or parameters</li>
<li>f is the objective function, a (scalar) function of x that we want to maximize or minimize</li>
<li>$c_i\ $are constraint functions, which are scalar functions of x that define equations and inequalities that the unknown vector x must satisfy</li>
</ul>
<p>Optimization problem can be written as follows by using the notations above:</p>
<script type="math/tex; mode=display">
\min_{x \in \R^n}\ f(x)\quad s.t.\ 
\begin{cases}
c_i(x) = 0\quad i \in \mathcal{E}\\
c_i(x)\ge 0\quad i \in \mathcal{I}
\end{cases}</script><p>Here $\ \mathcal{I}\ $and $\ \mathcal{E}\ $are sets of indexes for equality and inequality constraints, respectively.</p>
<ul>
<li>feasible region: the set of points satisfying all the constraints</li>
</ul>
<h3 id="Continuous-versus-Discrete-Optimization"><a href="#Continuous-versus-Discrete-Optimization" class="headerlink" title="Continuous versus Discrete Optimization"></a>Continuous versus Discrete Optimization</h3><h4 id="discrete-optimization"><a href="#discrete-optimization" class="headerlink" title="discrete optimization"></a>discrete optimization</h4><p>The defining feature of a discrete optimization problem is that the unknown x is drawn from a finite (but often very large) set.</p>
<h4 id="continuous-optimization"><a href="#continuous-optimization" class="headerlink" title="continuous optimization"></a>continuous optimization</h4><p>The feasible set is usually uncountably infinite, as when the components of x are allowed to be real numbers.</p>
<p>Continuous optimization problems are normally easier to solve because the smoothness of the functions makes it possible to use objective and constraint information at a particular point x to deduce information about the function’s behavior at all points close to x.</p>
<p>Continuous optimization techniques often play an important role in solving discrete optimization problems.</p>
<h3 id="Constrained-and-Unconstrained-Optimization"><a href="#Constrained-and-Unconstrained-Optimization" class="headerlink" title="Constrained and Unconstrained Optimization"></a>Constrained and Unconstrained Optimization</h3><h4 id="unconstrained-optimization"><a href="#unconstrained-optimization" class="headerlink" title="unconstrained optimization"></a>unconstrained optimization</h4><ul>
<li>$\mathcal{I} = \mathcal{E} = \emptyset$</li>
<li>replacement the constraints by the penalization terms added to objective function</li>
</ul>
<h4 id="constrained-optimization"><a href="#constrained-optimization" class="headerlink" title="constrained optimization"></a>constrained optimization</h4><h3 id="Stochastic-and-Deterministic-Optimization"><a href="#Stochastic-and-Deterministic-Optimization" class="headerlink" title="Stochastic and Deterministic Optimization"></a>Stochastic and Deterministic Optimization</h3><p>Stochastic optimization algorithms use these quantifications of the uncertainty to produce solutions that optimize the expected performance of the model.</p>
<ul>
<li>chance-constrained optimization: in which we ensure that the variables satisfy the given constraints to some specified probability</li>
<li>robust optimization: certain constraints are required to hold for all possible values of the uncertain data</li>
</ul>
<h3 id="Convexity"><a href="#Convexity" class="headerlink" title="Convexity"></a>Convexity</h3><p>First of all, we consider convex set.</p>
<h4 id="convex-set"><a href="#convex-set" class="headerlink" title="convex set"></a>convex set</h4><p>When we say a set is convex, it follows that for $\forall x \in S$ and $y\in S$, we have</p>
<script type="math/tex; mode=display">
\alpha x + (1-\alpha)y \in S \quad \forall \alpha\in[0,1]</script><h4 id="convex-function"><a href="#convex-function" class="headerlink" title="convex function"></a>convex function</h4><ul>
<li><p>convex function: if its domain S is a convex set and if for any two points x and y in S, the following property is satisfied</p>
<script type="math/tex; mode=display">
f(\alpha x+(1-\alpha)y)\le\alpha f(x)+(1-\alpha)f(y)\quad \forall \alpha \in[0,1]</script></li>
<li><p>strictly convex function: whenever $x \ne y$</p>
<script type="math/tex; mode=display">
f(\alpha x+(1-\alpha)y)\lt \alpha f(x)+(1-\alpha)f(y)\quad \forall \alpha \in[0,1]</script></li>
<li><p>convex function</p>
</li>
</ul>
<h4 id="global-solution"><a href="#global-solution" class="headerlink" title="global solution"></a>global solution</h4><p>If the objective function in the optimization problem and the feasible region are both convex, then any local solution of the problem is in fact a global solution.</p>
<h4 id="convex-programming"><a href="#convex-programming" class="headerlink" title="convex programming"></a>convex programming</h4><p>A special case of the general constrained optimization problem in which</p>
<ul>
<li>the objective function is convex</li>
<li>the equality constrain function $c_i(\cdot), i\in\mathcal{E}$, are linear</li>
<li>the inequality constrain function $c_i(\cdot), i\in\mathcal{I}$, are concave</li>
</ul>
<h3 id="Optimization-Algorithm"><a href="#Optimization-Algorithm" class="headerlink" title="Optimization Algorithm"></a>Optimization Algorithm</h3><p>Most strategies make use of the values of the objective function f, $c_i$, the constraint functions, and possibly the first and second derivatives of these functions. Some algorithms accumulate information gathered at previous iterations, while others use only local information obtained at the current point.</p>
<p>Aspects of judging whether the algorithm is a good or not:</p>
<ul>
<li>Robustness</li>
<li>Efficiency</li>
<li>Accuracy</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>Numerical Optimization (2nd) by Jorge Nocedal, Stephen J. Wright</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/15/%E5%9B%9B%E4%B8%AD%E6%B1%87%E6%8A%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/15/%E5%9B%9B%E4%B8%AD%E6%B1%87%E6%8A%A5/" class="post-title-link" itemprop="url">四中汇报</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-15 13:22:02 / Modified: 13:44:05" itemprop="dateCreated datePublished" datetime="2022-04-15T13:22:02+08:00">2022-04-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Summary/" itemprop="url" rel="index"><span itemprop="name">Summary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h4><p>在本月中，我的生活发生了很多变化，不仅仅是学习生活，更包括一些心理上的变化。</p>
<p>在这里我主要谈谈学习生活的变化，当然这不可避免的会谈及到心理层面的东西。</p>
<p>一是我暂缓了泛函分析的学习，原因有两个：</p>
<ul>
<li>泛函分析的学习达到了一个瓶颈，想要再继续深入学习下去需要花费我更加多的时间和精力。</li>
<li>心理层面的一些问题导致我需要一个比较宽松的，节奏比较舒缓的方式以确保能保证最低强度的学习</li>
</ul>
<p>二是偏微分方程的学习，基本上达成进度比学校快一章节的目标，这也很有预见性的给我上一点所提到的舒缓的学习节奏提供了缓冲的可能。</p>
<h4 id="srp"><a href="#srp" class="headerlink" title="srp"></a>srp</h4><p>开了短短不到一小时的会，与srp的指导老师和各位师兄见了面。本次srp项目一改往常的方式，不是每周一个组会汇报进展（考虑到大二大三的学生课程安排比较紧张，安排出一个大家都有空闲的时间统一开组会似乎都做不到），所以决定通过研究生带领一到两位本科生的方式。分配给我的师兄看起来非常的和蔼可亲哈哈哈，希望能够在他的带领下快速的成长起来。</p>
<p>夏栗老师首先提到了一件事，那就是让研究生们先带领我们学习做科研是这么样子的流程，这是一个很重要的问题，不过先按下不表。</p>
<p>ps.夏栗老师本尊看起来就非常像能读博士的人</p>
<h4 id="opencv"><a href="#opencv" class="headerlink" title="opencv"></a>opencv</h4><h4 id="BTM"><a href="#BTM" class="headerlink" title="BTM"></a>BTM</h4><p>本月比较有结果的工作就是完成了关于对欧式、美式看涨、看跌期权的二叉树定价模型，包括无股息、连续股息红利率、派发一次性股息情形、上升-敲出期权以及蝶式期权的定价。</p>
<h4 id="慢节奏"><a href="#慢节奏" class="headerlink" title="慢节奏"></a>慢节奏</h4><p>其实本月的工作强度并不是很大，并不像上个月那么高产和充满干劲。</p>
<h3 id="下个月目标"><a href="#下个月目标" class="headerlink" title="下个月目标"></a>下个月目标</h3><ul>
<li><p>摸索如何调整自己的节奏和情绪</p>
</li>
<li><p>正常更新五中汇报</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/08/Option-Price-Binary-Tree-Modeling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/08/Option-Price-Binary-Tree-Modeling/" class="post-title-link" itemprop="url">Option Price - Binary Tree Modeling</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-08 14:06:47 / Modified: 14:08:21" itemprop="dateCreated datePublished" datetime="2022-04-08T14:06:47+08:00">2022-04-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Mathematical-Finance/" itemprop="url" rel="index"><span itemprop="name">Mathematical Finance</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a><center>第一部分</center></h3><p>已知某股票当前价格为100美元，股票波动率为25%，无风险利率为5%。考虑以该股票为标的的资产的期权。</p>
<h5 id="无股息"><a href="#无股息" class="headerlink" title="无股息"></a>无股息</h5><blockquote>
<p>假设股票在期权有效期内不支付股息，取步数为500，1000，1500，2000，利用二叉树模型对有效期为半年、执行价格为100美元的欧式和美式看涨、看跌期权定价，并针对数值结果进行合理的分析。</p>
</blockquote>
<p>看涨期权则是估计这个股票会涨，可以在未来以一定的价格买进；看跌期权是估计股价会跌，可以在未来以一定价格卖出。</p>
<p>美式期权<code>(American options)</code>是指允许期权的持有人在期权的有效期的到期日之前任何一天均可履行合约的期权；欧式期权<code>(European options)</code>是指仅允许期权的持有人在期权的有效期最后一天方可履行合约的期权。</p>
<center>代码示例</center>

<p>以欧式看涨期权为例：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">btm_EurCall</span><span class="params">(S0, K, vol, r, T, N)</span> </span></span><br><span class="line"><span class="comment">% 初始化参数</span></span><br><span class="line">dt = T/N; </span><br><span class="line">u = <span class="built_in">exp</span>(vol*<span class="built_in">sqrt</span>(dt));</span><br><span class="line">d = <span class="number">1</span>/u;</span><br><span class="line">p = (<span class="built_in">exp</span>(r*dt)-d)/(u-d);</span><br><span class="line"><span class="comment">% 创建期权价格数组并进行初始化</span></span><br><span class="line">V = <span class="built_in">zeros</span>(<span class="number">2</span>*N+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = -N:<span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 最终节点期权的收益为到期日股票价格S_T减去执行价格K的正部</span></span><br><span class="line">    V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>(S0*u^<span class="built_in">j</span>-K, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 倒推</span></span><br><span class="line"><span class="keyword">for</span> n = N<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = -n:<span class="number">2</span>:n</span><br><span class="line">        <span class="comment">% 当前期权价格由前一步相邻两个期权价格以无风险期望贴现</span></span><br><span class="line">        V(<span class="built_in">j</span>+N+<span class="number">1</span>) = (p*V(<span class="built_in">j</span>+<span class="number">1</span>+N+<span class="number">1</span>) + (<span class="number">1</span>-p)*V(<span class="built_in">j</span><span class="number">-1</span>+N+<span class="number">1</span>))*<span class="built_in">exp</span>(-r*dt);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 返回初始时刻期权价格</span></span><br><span class="line">y = V(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<center>数值结果</center>

<p>首先我们先进行参数设定：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S0 = <span class="number">100</span>; <span class="comment">% 股票初始价格</span></span><br><span class="line">r = <span class="number">0.05</span>; <span class="comment">% 无风险利率</span></span><br><span class="line">K = <span class="number">100</span>; <span class="comment">% 敲定价格</span></span><br><span class="line">N = <span class="number">100</span>:<span class="number">100</span>:<span class="number">2000</span>; <span class="comment">% 步数</span></span><br><span class="line">T = <span class="number">0.5</span>; <span class="comment">% 到期日时间</span></span><br><span class="line">vol = <span class="number">0.25</span>; <span class="comment">% 股票波动率</span></span><br></pre></td></tr></table></figure>
<p>以下是二叉树模型在不同步数设置下（<code>100:100:2000</code>）给出的数值结果：</p>
<ol>
<li><p>欧式看涨期权定价</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">eurcall = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(N)</span><br><span class="line">    call = btm_EurCall(S0, K, vol, r, T, N(<span class="built_in">i</span>));</span><br><span class="line">    eurcall = [eurcall, call];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">[blscall, blsput] = blsprice(S0, K, r, T, vol);</span><br><span class="line"><span class="built_in">plot</span>(N, eurcall, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">hline = refline([<span class="number">0</span> blscall]);</span><br><span class="line">hline.Color = <span class="string">&#x27;r&#x27;</span>;</span><br><span class="line">ylim([<span class="number">8.242</span>, blscall+<span class="number">0.002</span>])</span><br><span class="line">xlabel(<span class="string">&#x27;steps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;European Call Option Price&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(&#123;<span class="string">&#x27;Erucall&#x27;</span>,<span class="string">&#x27;blsprice&#x27;</span>&#125;, <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;SouthEast&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> off</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/1.png" style="zoom:50%;"></p>
<p>图中所示红线为<code>Black Scholes</code>所计算的期权价格，可以看到随着步数的增加，欧式看涨期权的价格逐渐逼近<code>blsprice</code>。</p>
</li>
<li><p>欧式看跌期权定价</p>
<p>类似上述的代码，我们可以得到不同步数设置下由二叉树模型所得的期权价格</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/2.png" style="zoom:50%;"></p>
<p>同样的，红线所示为<code>Black Scholes</code>所计算出的期权价格，我们的数值结果随着步数的增加同样在不断逼近该价格。结合第一点欧式看涨期权我们可以直观的看到欧式看涨期权的价格更贵。</p>
</li>
<li><p>美式看涨期权定价</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">amcall = [];</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(N)</span><br><span class="line">    call = btm_AmCall(S0, K, vol, r, T, N(<span class="built_in">i</span>));</span><br><span class="line">    amcall = [amcall, call];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(N, amcall, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;steps&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;American Call Option Price&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/3.png" style="zoom:50%;"></p>
</li>
<li><p>美式看跌期权定价</p>
<p>相应的我们也给出美式看跌期权的数值结果</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/4.png" style="zoom:50%;"></p>
</li>
</ol>
<p>下面我们将美式期权与欧式期权进行横向对比：</p>
<ol>
<li><p>欧式看涨期权与美式看涨期权对比</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/5.png" style="zoom:50%;"></p>
<p>虽然美式看涨期权赋予期权持有人在到期日之前行使期权的权利，理论上美式期权的价格理应更高，但是由于看涨期权持有人在到期日之前行使期权并不能使他获得更多收益，所以在不派发股息的情况下，欧式与美式看涨期权价格并没有区别。</p>
</li>
<li><p>欧式看跌期权与美式看跌期权对比</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/6.png" style="zoom:50%;"></p>
<p>前面说到欧式与美式看涨期权价格在不派发股息的情况下并没有不同，但是对于看跌期权，情况则有所不同，美式看跌期权价格要比欧式看跌期权价格更高。</p>
</li>
</ol>
<h5 id="上升-敲出期权"><a href="#上升-敲出期权" class="headerlink" title="上升-敲出期权"></a>上升-敲出期权</h5><blockquote>
<p>仍然假设股票不支付股息，取步数为500，100，1500，200，利用二叉树模型对有效期为半年、执行价格为100美元的欧式和美式上升-敲出期权的价格，并针对结果给出金融解释。</p>
</blockquote>
<p>鲨鱼鳍期权又称为敲出期权<code>(knock-out options)</code>，属于障碍期权<code>(barrier options)</code>的一种。期权合约会事先设置好标的资产的价格区间，如果在合约约定的时间范围内，标的资产价格始终处于该区间中，这个期权就是一个普通的看涨或看跌期权；一旦标的资产价格跳出了该区间，该期权将自动敲出作废。鲨鱼鳍期权作为一种<strong>路径依赖</strong>的期权，<strong>限定了投资者可获的最大收益</strong>，所以相对于香草期权<strong>更便宜</strong>，对于相信标的资产在未来一段时间内会发生确定方向的变化，但是不会越过障碍价格的投资者非常有吸引力。</p>
<p>下表以上升-敲出看涨期权为例展示了多头方到期日的收益（期权价格不计入其中）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>上升-敲出看涨期权的到期收益</th>
<th style="text-align:center">标的资产到期价格</th>
<th style="text-align:center">看涨期权多头到期日收益</th>
</tr>
</thead>
<tbody>
<tr>
<td>标的资产在合约期间不超过障碍价格</td>
<td style="text-align:center">$S_T&gt;=K$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">$S_T&gt;K$</td>
<td style="text-align:center">$S_T-K$</td>
</tr>
<tr>
<td>标的资产在合约期间超过了障碍价格</td>
<td style="text-align:center">$S_T&gt;=K$</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">$S_T&gt;K$</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
</div>
<p>注意到对于一般的路径有关期权，我们并不能直接通过二叉树模型对期权进行定价，因为期权在到期日的收益依赖于股票价格路径，树末端节点处的收益并不明确。但是对于上述这种障碍期权，我们仍然可以使用二叉树模型对其进行定价。</p>
<center>代码示例</center>

<p>以美式上升-敲出期权为例：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">btm_AmUpAndOut</span><span class="params">(S0, K, vol, r, T, N, H)</span></span></span><br><span class="line"><span class="comment">% 参数初始化</span></span><br><span class="line">dt = T/N;</span><br><span class="line">u = <span class="built_in">exp</span>(vol*<span class="built_in">sqrt</span>(dt));</span><br><span class="line">d = <span class="number">1</span>/u;</span><br><span class="line">p = (<span class="built_in">exp</span>(r*dt)-d)/(u-d);</span><br><span class="line">k = <span class="built_in">ceil</span>(<span class="built_in">log</span>(H/S0)/<span class="built_in">log</span>(u)); <span class="comment">% 障碍</span></span><br><span class="line"><span class="comment">% 创建期权价格数组并进行初始化</span></span><br><span class="line">V = <span class="built_in">zeros</span>(<span class="number">2</span>*N+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = -N:<span class="number">2</span>:N</span><br><span class="line">    V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>(S0*u^<span class="built_in">j</span>-K, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 倒推</span></span><br><span class="line"><span class="keyword">for</span> n = N<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = -n:<span class="number">2</span>:n</span><br><span class="line">        <span class="comment">% 当前期权价格为以下两者之间取最大值:</span></span><br><span class="line">        <span class="comment">% 1. 前一步相邻两个期权价格以无风险期望贴现</span></span><br><span class="line">        <span class="comment">% 2. 当前直接行使期权获得的收益</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">j</span> &lt; k</span><br><span class="line">            V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>((p*V(<span class="built_in">j</span>+<span class="number">1</span>+N+<span class="number">1</span>)+(<span class="number">1</span>-p)*V(<span class="built_in">j</span><span class="number">-1</span>+N+<span class="number">1</span>))*<span class="built_in">exp</span>(-r*dt), S0*u^<span class="built_in">j</span>-K);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span>      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 返回初始时刻期权价格</span></span><br><span class="line">y = V(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<center>数值结果</center>

<p>我们首先进行参数的设定：假定障碍价格H为140</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S0 = <span class="number">100</span>; <span class="comment">% 股票初始价格</span></span><br><span class="line">r = <span class="number">0.05</span>; <span class="comment">% 无风险利率</span></span><br><span class="line">K = <span class="number">100</span>; <span class="comment">% 敲定价格</span></span><br><span class="line">N = <span class="number">100</span>:<span class="number">100</span>:<span class="number">2000</span>; <span class="comment">% 步数</span></span><br><span class="line">T = <span class="number">0.5</span>; <span class="comment">% 到期日时间</span></span><br><span class="line">vol = <span class="number">0.25</span>; <span class="comment">% 股票波动率</span></span><br><span class="line">H = <span class="number">140</span>; <span class="comment">% 障碍价格 </span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>欧式上升-敲出期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/17.png" style="zoom:50%;"></p>
</li>
<li><p>美式上升-敲出期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/18.png" style="zoom:50%;"></p>
</li>
</ol>
<p>设置步数为2000，我们研究在不同障碍价格设定对欧式、美式上升-敲出期权的影响：</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/19.png" style="zoom:50%;"></p>
<p>可以看到障碍价格对欧式期权的影响要比美式期权的影响更大。直观上这也很好理解：美式期权赋予期权持有人在到期日之前行使期权的权利，所以当股票价格逼近障碍价格时，美式期权持有人很有可能提前行使期权。</p>
<h5 id="支付连续股息"><a href="#支付连续股息" class="headerlink" title="支付连续股息"></a>支付连续股息</h5><blockquote>
<p>假设股票支付连续股息，股票收益率为2%，取步数为500，1000，1500，2000，利用二叉树模型对有效期为半年、执行价格为100美元的欧式、美式看涨、看跌期权定价，并针对数值结果进行合理的分析。</p>
</blockquote>
<p>假设某股票支付连续收益率为$\ q\ $的股息。在风险中性世界里股息收益率加上资产收益<code>(capital gain)</code>率的总和等于$\ 𝑟$，股息收益率为$\ 𝑞$，因此资本收益率为$\ 𝑟−𝑞$。</p>
<ol>
<li><p>资本收益率的变化最终会导致股价上涨概率$\ p\ $的变化</p>
<script type="math/tex; mode=display">
p = \frac{e^{(r-q)\Delta t}-d}{u-d}</script></li>
<li><p>在风险中性世界里，期权的价格等于其未来价格的数学期望以无风险利率$\ r\ $进行贴现</p>
<script type="math/tex; mode=display">
f = [p*f_u + (1-p)*f_d]e^{-r\Delta t}</script></li>
</ol>
<center>代码示例</center>

<p>以美式看涨期权为例：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">btm_AmCall_ctDiv</span><span class="params">(S0, K, vol, r, T, N, q)</span></span></span><br><span class="line"><span class="comment">% 参数初始化</span></span><br><span class="line">dt = T/N;</span><br><span class="line">u = <span class="built_in">exp</span>(vol*<span class="built_in">sqrt</span>(dt));</span><br><span class="line">d = <span class="number">1</span>/u;</span><br><span class="line">p = (<span class="built_in">exp</span>((r-q)*dt)-d)/(u-d); <span class="comment">% 连续支付股息导致股票上涨概率发生变化</span></span><br><span class="line"><span class="comment">% 创建期权价格数组并进行初始化</span></span><br><span class="line">V = <span class="built_in">zeros</span>(<span class="number">2</span>*N+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = -N:<span class="number">2</span>:N</span><br><span class="line">    V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>(S0*u^<span class="built_in">j</span>-K, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 倒推</span></span><br><span class="line"><span class="keyword">for</span> n = N<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = -n:<span class="number">2</span>:n</span><br><span class="line">        <span class="comment">% 当前期权价格为以下两者之间取最大值:</span></span><br><span class="line">        <span class="comment">% 1. 前一步相邻两个期权价格以无风险期望贴现</span></span><br><span class="line">        <span class="comment">% 2. 当前直接行使期权获得的收益</span></span><br><span class="line">        V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>((p*V(<span class="built_in">j</span>+<span class="number">1</span>+N+<span class="number">1</span>)+(<span class="number">1</span>-p)*V(<span class="built_in">j</span><span class="number">-1</span>+N+<span class="number">1</span>))*<span class="built_in">exp</span>(-r*dt), S0*u^<span class="built_in">j</span>-K);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 返回初始时刻期权价格</span></span><br><span class="line">y = V(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<center>数值结果</center>

<p>首先我们先进行参数设定：设定股票收益率为2%</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S0 = <span class="number">100</span>; <span class="comment">% 股票初始价格</span></span><br><span class="line">r = <span class="number">0.05</span>; <span class="comment">% 无风险利率</span></span><br><span class="line">K = <span class="number">100</span>; <span class="comment">% 敲定价格</span></span><br><span class="line">N = <span class="number">100</span>:<span class="number">100</span>:<span class="number">2000</span>; <span class="comment">% 步数</span></span><br><span class="line">T = <span class="number">0.5</span>; <span class="comment">% 到期日时间</span></span><br><span class="line">vol = <span class="number">0.25</span>; <span class="comment">% 股票波动率</span></span><br><span class="line">q = <span class="number">0.02</span>; <span class="comment">% 股息率</span></span><br></pre></td></tr></table></figure>
<p>在呈现支付连续股息的结果时，将同时与无股息情形进行比较</p>
<ol>
<li><p>看涨期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/7.png" style="zoom:50%;"></p>
<p>在支付连续股息的情况下，看涨期权的价格下降，这是由于</p>
</li>
<li><p>看跌期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/8.png" style="zoom:50%;"></p>
<p>在支付连续股息的情况下，看跌期权价格有所上升。这是因为股息的存在降低了资本收益率，导致股票价格上涨的概率降低，而这对于看跌期权是有益的。</p>
</li>
</ol>
<h5 id="支付一次性股息"><a href="#支付一次性股息" class="headerlink" title="支付一次性股息"></a>支付一次性股息</h5><blockquote>
<p>假设该股票将于2个月后一次性支付股息，金额为当时股价的2%，取步数为500，1000，1500，2000，利用二叉树模型对有效期为半年、执行价格为100美元的欧式和美式看涨、看跌期权定价，并针对数值结果给出合理的分析。</p>
</blockquote>
<p>假定股票只在某个离散时刻点上支付一次股息，而且股息为当时股价的$\ \delta\ $倍，其他参数与没有股息情形下一样。</p>
<center>代码示例</center>

<p>以美式看跌期权为例：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">btm_AmPut_Div</span><span class="params">(S0, K, vol, r, T, N, delta, date)</span></span></span><br><span class="line"><span class="comment">% 参数初始化</span></span><br><span class="line">dt = T/N;</span><br><span class="line">u = <span class="built_in">exp</span>(vol*<span class="built_in">sqrt</span>(dt));</span><br><span class="line">d = <span class="number">1</span>/u;</span><br><span class="line">p = (<span class="built_in">exp</span>(r*dt)-d)/(u-d);</span><br><span class="line"><span class="built_in">i</span> = <span class="built_in">ceil</span>(N*date/T); <span class="comment">% 派发一次性股息对应的节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建期权价格数组并进行初始化</span></span><br><span class="line">V = <span class="built_in">zeros</span>(<span class="number">2</span>*N+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = -N:<span class="number">2</span>:N</span><br><span class="line">    V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>(S0*u^<span class="built_in">j</span>*delta-K, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 倒推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 除息日之后</span></span><br><span class="line"><span class="keyword">for</span> n = N<span class="number">-1</span>:<span class="number">-1</span>:<span class="built_in">i</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = -n:<span class="number">2</span>:n</span><br><span class="line">        <span class="comment">% 当前期权价格为以下两者之间取最大值:</span></span><br><span class="line">        <span class="comment">% 1. 前一步相邻两个期权价格以无风险期望贴现</span></span><br><span class="line">        <span class="comment">% 2. 当前直接行使期权获得的收益</span></span><br><span class="line">        V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>((p*V(<span class="built_in">j</span>+<span class="number">1</span>+N+<span class="number">1</span>)+(<span class="number">1</span>-p)*V(<span class="built_in">j</span><span class="number">-1</span>+N+<span class="number">1</span>))*<span class="built_in">exp</span>(-r*dt), K-S0*u^<span class="built_in">j</span>*(<span class="number">1</span>-delta));</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 除息日之前</span></span><br><span class="line"><span class="keyword">for</span> n = <span class="built_in">i</span><span class="number">-1</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = -n:<span class="number">2</span>:n</span><br><span class="line">        V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>((p*V(<span class="built_in">j</span>+<span class="number">1</span>+N+<span class="number">1</span>)+(<span class="number">1</span>-p)*V(<span class="built_in">j</span><span class="number">-1</span>+N+<span class="number">1</span>))*<span class="built_in">exp</span>(-r*dt), K-S0*u^<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 返回初始时刻期权价格</span></span><br><span class="line">y = V(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<center>数值结果</center>

<p>首先我们先进行参数设定：设置一次性股息收益率为当前股票价格的2%，同时假设股息派发时间为2个月之后</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S0 = <span class="number">100</span>; <span class="comment">% 股票初始价格</span></span><br><span class="line">r = <span class="number">0.05</span>; <span class="comment">% 无风险利率</span></span><br><span class="line">K = <span class="number">100</span>; <span class="comment">% 敲定价格</span></span><br><span class="line">N = <span class="number">100</span>:<span class="number">100</span>:<span class="number">2000</span>; <span class="comment">% 步数</span></span><br><span class="line">T = <span class="number">0.5</span>; <span class="comment">% 到期日时间</span></span><br><span class="line">vol = <span class="number">0.25</span>; <span class="comment">% 股票波动率</span></span><br><span class="line">delta = <span class="number">0.02</span>; <span class="comment">% 一次性股息收益率</span></span><br><span class="line">date = <span class="number">1</span>/<span class="number">6</span>; <span class="comment">% 股息派发时间</span></span><br></pre></td></tr></table></figure>
<p>下面我们将直接将支付一次性股息的情形与无股息情形进行对比：</p>
<ol>
<li><p>欧式看涨期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/13.png" style="zoom:50%;"></p>
</li>
<li><p>欧式看跌期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/14.png" style="zoom:50%;"></p>
</li>
<li><p>美式看涨期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/15.png" style="zoom:50%;"></p>
</li>
<li><p>美式看跌期权</p>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/16.png" style="zoom:50%;"></p>
</li>
</ol>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a><center>第二部分</center></h3><p>已知某股票波动率为25%，无风险利率为5%。考虑以该股票为原生资产的半年期、敲定价格为100美元的欧式看涨、看跌期权。</p>
<blockquote>
<p>利用二叉树模型求出初始股票价格为$\ 90:1:110\ $时的欧式看涨、看跌期权的初始价格，并计算出相应的Delta值。</p>
</blockquote>
<p>假设在二叉树的某个节点上，股票价格和期权价格分别为$\ S_i\ $和$\ f_i\ $，下一步股票价格可能上涨到$\ uS_i\ $或者降为$\ dS_i\ $，相应的期权价格变成$\ f_{i,u}\ $或者$\ f_{i,d}\ $。</p>
<p>由无套利定价方法，我们知道看涨期权出售方可持有$\Delta = \frac{f_{i,u}-f_{i,d}}{uS_i-dS_i}\ $单位股票对冲掉卖出一份看涨期权所带来的风险。</p>
<p>由于每一个节点所计算出来的$\ \Delta\ $值不同，所以我们在利用股票和期权进行风险对冲时，我们需要不断调整所持股票的数量。</p>
<blockquote>
<p>已知蝶式期权时一种欧式期权，它在到期日的收益等于</p>
<script type="math/tex; mode=display">
max\{0,min\{S_T-90, 110-S_T\}\}</script><p>利用二叉树模型求出初始股票价格为$\ 90:1:110\ $时的蝶式期权的初始价格，并计算出相应点的Delta值。</p>
</blockquote>
<center>代码示例</center>

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">y</span> = <span class="title">btm_EurButterfly</span><span class="params">(S0, vol, r, T, N)</span> </span></span><br><span class="line"><span class="comment">% 初始化参数</span></span><br><span class="line">dt = T/N; </span><br><span class="line">u = <span class="built_in">exp</span>(vol*<span class="built_in">sqrt</span>(dt));</span><br><span class="line">d = <span class="number">1</span>/u;</span><br><span class="line">p = (<span class="built_in">exp</span>(r*dt)-d)/(u-d);</span><br><span class="line"><span class="comment">% 创建期权价格数组并进行初始化</span></span><br><span class="line">V = <span class="built_in">zeros</span>(<span class="number">2</span>*N+<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = -N:<span class="number">2</span>:N</span><br><span class="line">    <span class="comment">% 最终节点期权的收益为到期日股票价格S_T减去执行价格K的正部</span></span><br><span class="line">    V(<span class="built_in">j</span>+N+<span class="number">1</span>) = <span class="built_in">max</span>(<span class="built_in">min</span>(S0*u^<span class="built_in">j</span><span class="number">-90</span>, <span class="number">110</span>-S0*u^<span class="built_in">j</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 倒推</span></span><br><span class="line"><span class="keyword">for</span> n = N<span class="number">-1</span>:<span class="number">-1</span>:<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = -n:<span class="number">2</span>:n</span><br><span class="line">        <span class="comment">% 当前期权价格由前一步相邻两个期权价格以无风险期望贴现</span></span><br><span class="line">        V(<span class="built_in">j</span>+N+<span class="number">1</span>) = (p*V(<span class="built_in">j</span>+<span class="number">1</span>+N+<span class="number">1</span>) + (<span class="number">1</span>-p)*V(<span class="built_in">j</span><span class="number">-1</span>+N+<span class="number">1</span>))*<span class="built_in">exp</span>(-r*dt);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 返回初始时刻期权价格</span></span><br><span class="line">y = V(N+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<center>数值结果</center>

<p>参数设定：设置股票价格为<code>90:1:110</code></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S0 = <span class="number">90</span>:<span class="number">1</span>:<span class="number">110</span>; <span class="comment">% 股票初始价格</span></span><br><span class="line">r = <span class="number">0.05</span>; <span class="comment">% 无风险利率</span></span><br><span class="line">K = <span class="number">100</span>; <span class="comment">% 敲定价格</span></span><br><span class="line">N = <span class="number">2000</span>; <span class="comment">% 步数</span></span><br><span class="line">T = <span class="number">0.5</span>; <span class="comment">% 到期日时间</span></span><br><span class="line">vol = <span class="number">0.25</span>; <span class="comment">% 股票波动率</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(S0)</span><br><span class="line">    BF = btm_EurButterfly(S0(<span class="built_in">i</span>), vol, r, T, N);</span><br><span class="line">    eurBF = [eurBF, BF];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">plot</span>(S0, eurBF, <span class="string">&#x27;*&#x27;</span>, LineStyle=<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;S_0 / Dollar&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;European Butterfly Options Price&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/04/08/Option-Price-Binary-Tree-Modeling/20.png" style="zoom:50%;"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/15/%E4%B8%89%E4%B8%AD%E6%B1%87%E6%8A%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/15/%E4%B8%89%E4%B8%AD%E6%B1%87%E6%8A%A5/" class="post-title-link" itemprop="url">三中汇报</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-15 15:42:15 / Modified: 15:43:27" itemprop="dateCreated datePublished" datetime="2022-03-15T15:42:15+08:00">2022-03-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Summary/" itemprop="url" rel="index"><span itemprop="name">Summary</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>It was so exciting to know that the ideas of some dead genius, could transport me and give me a <strong>glimmer of a higher realm</strong>.</p>
<p>振奋人心的是，我知道那些逝去的天才依然能够带我一把，去领略那更高的殿堂。</p>
<p>They held the belief, with a religious fervor, that the magic keys to the kingdom were in these books. The mysteries of life and how to live well were there for the seizing for those who <strong>read well and thought deeply</strong>.</p>
<p>他们怀着宗教般的热烈，相信通往极乐世界的魔法钥匙就在这些书中。生命的神秘以及美好生活的神性，就在这些书中，等着那些热爱阅读，思考深邃的人来发现。</p>
<p><strong>Intense struggling for the good</strong>.</p>
<p>对美好事物极力地争取。 </p>
</blockquote>
<p>三中汇报，其实就是在三月中旬对过往的一个月的工作和思想变化进行一些总结和反思。</p>
<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>最开始想要做这件事情的动机是想通过在每月中旬进行过去一个月内工作的总结和反思达到类似ddl的效果——在过去的一个月内能够尽可能高效高质量的完成多一些工作这样子在下次做汇报时才能有东西可以写……（笑，人人都是ddl人）</p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>为了规范，要求在汇报中必须将过去一个月中的重要事情与重大思想转变进行有效的分析</p>
<blockquote id="fn_1">
<sup>1</sup>. 有效的分析意味着写在这里的总结必须是过去一个月中不断进行思考和权衡的分析，而不是应付式的公式化的回答，倘若只是像为了完成一个任务一样去做这样的汇报，那么这个汇报不如不做。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<p>和反馈。同时在汇报末尾必须给出下个月应达成的目标。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="学习路径"><a href="#学习路径" class="headerlink" title="学习路径"></a>学习路径</h4><p>第一件事情我想要谈论的是关于学习方向和内容的改变。这学期我本来打算修习9门课：</p>
<ul>
<li>必修：<strong>偏微分方程</strong></li>
<li>选修：<strong>随机过程</strong>、数据挖掘与统计决策、<u>数理金融</u></li>
<li>旁听：<u>泛函分析</u>、蒙特卡罗方法、计算智能</li>
<li>通选：日本社会与文化、会计学</li>
<li>同时我还想在空闲时间学习：<strong>python</strong>、<u>统计学习方法</u>、测度论、离散数学</li>
<li>以及将过去一些知识进行复习：数学分析、概率论</li>
</ul>
<p>但是学了两周之后发现这对我来讲压力还是有点大，所以我最终还是想不能一下子将自己放在高压之下，即使想要进行高强度的学习，也要循序渐进。</p>
<p>以上标<strong>红色</strong>的就是学习的重点，我暂时将学习的中心放在这上面；另外标<u>下划线</u>的则是次重点。</p>
<p>其实思路很明确，首先必须要保证必修课<strong>偏微分方程</strong>的成绩。这是大学期间最后一门影响绩点的课程，所以在接下来的一个月中，全力以赴将这门课先搞定。</p>
<p>大概继续采取重点与次重点并进的方式，先搞定偏微分方程和泛函分析这两个大部头。</p>
<h4 id="关于笔记的问题"><a href="#关于笔记的问题" class="headerlink" title="关于笔记的问题"></a>关于笔记的问题</h4><p>过去这个月中我反而是将学习的中心有点放到了泛函分析上（虽然它并不被我列入学习的重点中，不过它确实很重要）</p>
<p>泛函分析是数学系本科阶段分析课程的巅峰，我也是出于一种对它的敬意和渴望在学习这门课的。所学习的课程是内蒙古大学孙炯老师所教授的泛函分析，他是一位很好的老师，讲课非常有逻辑性。</p>
<p>在这段时间的学习中我发现了一个严重的问题，那就是我因为不当的记笔记反而没有很好的掌握它的思想。</p>
<p>我想还是有必要重申一下听课笔记的事情：首先我必须先保证听课质量和吸收率，在听的过程中所记的笔记只能是对我有所启发的词汇或者是短句，不要将所有定理以及证明细节都写在笔记中。</p>
<p>我也不知道这种方法是否有效，尝试一个月吧。</p>
<p>最后，提醒自己一下，我之所以选择旁听这门课，是因为想摆脱考试的束缚，能够带着一种对知识强烈的渴望的心态学习它。</p>
<h4 id="srp-与-opencv"><a href="#srp-与-opencv" class="headerlink" title="srp 与 opencv"></a>srp 与 opencv</h4><p>第二件事情是申报了夏立老师的 srp ——基于机器学习进行神经元细胞的识别。不过目前并不知道这个项目是不是一个水项目……暂且当作它不是吧。</p>
<p>srp 要求对图像处理有些基础，那么这段时间我也是通过跟随别人做的一个项目进行 opencv 的学习。</p>
<p>申报 srp 的动机也应该提及一下：(undone)</p>
<h4 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h4><p>最近也是陆陆续续在更新博客，把我新学到的一些东西放在上面，不过基本上都是搬运或者翻译别人的东西，一个原因是我需要学习的东西还有很多，另外一点是原创性的东西做起来非常消耗精力，而且有一些新的点子放在草稿之上或许更加符合我这样一个（半吊子）数学系学生的习惯。</p>
<p>所以暂时我将我的博客定位为一个记录自己所学东西的一个地方，而且这些东西多数情况下是与一些技术相关的，而并不是与我本专业所学知识相关的。</p>
<p>虽然我也曾考虑过将自己学习数学和统计课程的一些想法和精要放在博客里，但是语言的组织和打数学公式非常耗时，所以我也在暂时搁置这个打算。</p>
<h3 id="下个月目标"><a href="#下个月目标" class="headerlink" title="下个月目标"></a>下个月目标</h3><ul>
<li>完成偏微分方程的学习，至少需要比学校进度快一个章节</li>
<li>随机过程的学习方式还需要再做调整</li>
<li>做好的笔记，而不是作完整的笔记</li>
<li>正常更新四中汇报</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/12/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B9%8B%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E5%80%BC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Shaw">
      <meta itemprop="description" content="Was mich nicht umbringt, macht mich stärker">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Shaw">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/12/%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E4%B9%8B%E5%A4%84%E7%90%86%E7%BC%BA%E5%A4%B1%E5%80%BC/" class="post-title-link" itemprop="url">数据清洗之处理缺失值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-03-12 14:49:58 / Modified: 14:58:47" itemprop="dateCreated datePublished" datetime="2022-03-12T14:49:58+08:00">2022-03-12</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Data-Cleaning/" itemprop="url" rel="index"><span itemprop="name">Data Cleaning</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="丢弃缺失值-通过自动化工作流补全"><a href="#丢弃缺失值-通过自动化工作流补全" class="headerlink" title="丢弃缺失值 & 通过自动化工作流补全"></a><center>丢弃缺失值 & 通过自动化工作流补全</center></h2><blockquote>
<p>这是来自 Kaggle Learn 的 Data Cleaning 课程。</p>
<p>在这个课程中，你将会学习如何处理一些常见的数据清洗问题，自己动手完成五个练习，它们都是一些真实的、杂乱的数据集。</p>
</blockquote>
<h3 id="初窥数据集"><a href="#初窥数据集" class="headerlink" title="初窥数据集"></a>初窥数据集</h3><p>首先我们导入将要使用到的库和数据集。作为范例，这里使用到了美国足球比赛发生事件的数据集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用的模块</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入所有数据</span></span><br><span class="line">nfl_data = pd.read_csv(<span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置随机种子以供复现</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>当我们获得一个新的数据集的时候，我们需要做的第一件事情就是查看其中的一部分数据。这将有助于确定数据是否正确读入并且给我们一些进行下一步操作的启示。在这一案例中，缺失数据将会以<code>NaN</code>或者<code>None</code>的形式出现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看数据集的前五行</span></span><br><span class="line">nfl_data.head()</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Date</th>
<th>GameID</th>
<th>Drive</th>
<th>qtr</th>
<th>down</th>
<th>time</th>
<th>TimeUnder</th>
<th>TimeSecs</th>
<th>PlayTimeDiff</th>
<th>SideofField</th>
<th>…</th>
<th>yacEPA</th>
<th>Home_WP_pre</th>
<th>Away_WP_pre</th>
<th>Home_WP_post</th>
<th>Away_WP_post</th>
<th>Win_Prob</th>
<th>WPA</th>
<th>airWPA</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>NaN</td>
<td>15:00</td>
<td>15</td>
<td>3600.0</td>
<td>0.0</td>
<td>TEN</td>
<td>…</td>
<td>NaN</td>
<td>0.485675</td>
<td>0.514325</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.485675</td>
<td>0.060758</td>
<td>NaN</td>
</tr>
<tr>
<td>1</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>1.0</td>
<td>14:53</td>
<td>15</td>
<td>3593.0</td>
<td>7.0</td>
<td>PIT</td>
<td>…</td>
<td>1.146076</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.546433</td>
<td>0.004655</td>
<td>-0.032244</td>
</tr>
<tr>
<td>2</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>2.0</td>
<td>14:16</td>
<td>15</td>
<td>3556.0</td>
<td>37.0</td>
<td>PIT</td>
<td>…</td>
<td>NaN</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.551088</td>
<td>-0.040295</td>
<td>NaN</td>
</tr>
<tr>
<td>3</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>3.0</td>
<td>13:35</td>
<td>14</td>
<td>3515.0</td>
<td>41.0</td>
<td>PIT</td>
<td>…</td>
<td>-5.031425</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.510793</td>
<td>-0.049576</td>
<td>0.106663</td>
</tr>
<tr>
<td>4</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>4.0</td>
<td>13:27</td>
<td>14</td>
<td>3507.0</td>
<td>8.0</td>
<td>PIT</td>
<td>…</td>
<td>NaN</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.558929</td>
<td>0.441071</td>
<td>0.461217</td>
<td>0.097712</td>
<td>NaN</td>
</tr>
</tbody>
</table>
</div>
<p>啊啊啊我们已经可以看到缺失数据的存在了！</p>
<h3 id="数据集中到底有多少缺失数据点呢？"><a href="#数据集中到底有多少缺失数据点呢？" class="headerlink" title="数据集中到底有多少缺失数据点呢？"></a>数据集中到底有多少缺失数据点呢？</h3><p>下面我们看看每一列都有多少缺失值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到每一行缺失值的个数</span></span><br><span class="line">missing_values_count = nfl_data.isnull().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前十列的缺失值个数</span></span><br><span class="line">missing_values_count[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Column Name</th>
<th style="text-align:center">Missing value numbers</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">GameID</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">Drive</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">qtr</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">down</td>
<td style="text-align:center">61154</td>
</tr>
<tr>
<td style="text-align:center">time</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">TimeUnder</td>
<td style="text-align:center">224</td>
</tr>
<tr>
<td style="text-align:center">TimeSecs</td>
<td style="text-align:center">224</td>
</tr>
<tr>
<td style="text-align:center">PlayTimeDiff</td>
<td style="text-align:center">444</td>
</tr>
<tr>
<td style="text-align:center">SideofField</td>
<td style="text-align:center">528</td>
</tr>
</tbody>
</table>
</div>
<p>看起来数据集中的缺失值还不少。此时计算数据的缺失百分比有助于我们俩了解问题的严重性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 总共有多少缺失值</span></span><br><span class="line">total_cells = np.product(nfl_data.shape)</span><br><span class="line">total_missing = missing_values_count.<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缺失数据所占百分比</span></span><br><span class="line">percent_missing = (total_missing/total_cells)*<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(percent_missing)</span><br><span class="line"></span><br><span class="line">Out[<span class="number">1</span>]:</span><br><span class="line"><span class="number">24.87214126835169</span></span><br></pre></td></tr></table></figure>
<p>哦偶，几乎四分之一的数据产生了缺失。那么下一步，我们就是要更仔细地查看一下每一列地缺失情况并且搞清楚究竟发生了什么状况。</p>
<h3 id="搞清楚为什么数据会缺失"><a href="#搞清楚为什么数据会缺失" class="headerlink" title="搞清楚为什么数据会缺失"></a>搞清楚为什么数据会缺失</h3><p><strong>数据直觉</strong>（或者说是<strong>数据敏感度</strong>？）是我们在进入数据科学领域非常关键的一点，简单来说就是要真切的对手头的数据进行观察并且尝试搞清楚为什么它会这样子以及它会对我们的数据分析产生什么影响。这可能会是数据科学令人感到非常沮丧的一部分，特别是当你初入一个领域并且没有相关的经验的时候。当面对缺失值的时候，你需要利用你的直觉想清楚为什么这个值会缺失。其中有一个十分重要的问题，或许你可以常常反问自己。</p>
<blockquote>
<p><strong>Is this value missing because it wasn’t recorded or because it doesn’t exist?</strong></p>
<p>这个值缺失究竟是因为它没有被记录还是因为它不存在？</p>
</blockquote>
<p>如果一个数据缺失仅仅是因为它压根不存在，那么你根本不需要费劲去猜它原来究竟是什么，你可能只是想让它保持<code>NaN</code>就行了。如果一个数据缺失是因为它没有被记录，那么你可以根据这一列的其他数据尝试去猜它的值究竟是什么。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前十列缺失值个数</span></span><br><span class="line">missing_values_count[<span class="number">0</span>:<span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>(undone)</p>
<h3 id="丢弃缺失值"><a href="#丢弃缺失值" class="headerlink" title="丢弃缺失值"></a>丢弃缺失值</h3><p>如果你很着急或者没有什么理由搞清楚这些缺失值产生的原因，那么你可以选择简单地把含有缺失值的行或者列直接删除。（贴士：我通常不建议在一些重要的项目上使用这种方法，往往花费时间去浏览你的数据并且将每一列中所含缺失值都看一遍以真正了解你的数据集）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有带有缺失值的行（样本点）</span></span><br><span class="line">nfl_data.dropna()</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Date</th>
<th>GameID</th>
<th>Drive</th>
<th>qtr</th>
<th>down</th>
<th>time</th>
<th>TimeUnder</th>
<th>TimeSecs</th>
<th>PlayTimeDiff</th>
<th>SideofField</th>
<th>…</th>
<th>yacEPA</th>
<th>Home_WP_pre</th>
<th>Away_WP_pre</th>
<th>Home_WP_post</th>
<th>Away_WP_post</th>
<th>Win_Prob</th>
<th>WPA</th>
<th>airWPA</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>好家伙，看起来我们直接将所有数据都删除了！这是因为我们的每一行数据中都至少含有一个缺失值。移除至少含一个缺失值的那些列或许更有可行性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除所有至少有一个缺失值的列</span></span><br><span class="line">columns_with_na_dropped = nfl_data.dropna(axis=<span class="number">1</span>)</span><br><span class="line">columns_with_na_dropped.head()</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>Date</th>
<th>GameID</th>
<th>Drive</th>
<th>qtr</th>
<th>TimeUnder</th>
<th>ydstogo</th>
<th>ydsnet</th>
<th>PlayAttempted</th>
<th>Yards.Gained</th>
<th>sp</th>
<th>…</th>
<th>Timeout_Indicator</th>
<th>Timeout_Team</th>
<th>posteam_timeouts_pre</th>
<th>HomeTimeouts_Remaining_Pre</th>
<th>AwayTimeouts_Remaining_Pre</th>
<th>HomeTimeouts_Remaining_Post</th>
<th>AwayTimeouts_Remaining_Post</th>
<th>ExPoint_Prob</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>15</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>39</td>
<td>0</td>
<td>…</td>
<td>0</td>
<td>None</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0.0</td>
</tr>
<tr>
<td>1</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>15</td>
<td>10</td>
<td>5</td>
<td>1</td>
<td>5</td>
<td>0</td>
<td>…</td>
<td>0</td>
<td>None</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0.0</td>
</tr>
<tr>
<td>2</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>15</td>
<td>5</td>
<td>2</td>
<td>1</td>
<td>-3</td>
<td>0</td>
<td>…</td>
<td>0</td>
<td>None</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0.0</td>
</tr>
<tr>
<td>3</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>14</td>
<td>8</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>…</td>
<td>0</td>
<td>None</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0.0</td>
</tr>
<tr>
<td>4</td>
<td>2009-09-10</td>
<td>2009091000</td>
<td>1</td>
<td>1</td>
<td>14</td>
<td>8</td>
<td>2</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>…</td>
<td>0</td>
<td>None</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>0.0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我们丢失了多少数据</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Columns in orginal dataset: %d \n&quot;</span> % nfl_data.shape[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Columns with na&#x27;s dropped: %d \n&quot;</span> % columns_with_na_dropped.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">Out[<span class="number">2</span>]:</span><br><span class="line">Columns <span class="keyword">in</span> original dataset: <span class="number">102</span></span><br><span class="line">Columns <span class="keyword">with</span> na<span class="string">&#x27;s dropped: 41</span></span><br></pre></td></tr></table></figure>
<p>这样子我们丢失了不少数据，但是至少我们成功从我们的数据中移除了所有<code>NaN</code>数据。</p>
<h3 id="自动填充缺失值"><a href="#自动填充缺失值" class="headerlink" title="自动填充缺失值"></a>自动填充缺失值</h3><p>另一种选择时尝试填补这些缺失值，在下一部分，我们只取该数据集的一小部分以方便我们将数据输出。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取NFL数据集中的一个小部分</span></span><br><span class="line">subset_nfl_data =  nfl_data.loc[:, <span class="string">&#x27;EPA&#x27;</span>:<span class="string">&#x27;Season&#x27;</span>].head()</span><br><span class="line">subset_nfl_data</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>EPA</th>
<th>airEPA</th>
<th>yacEPA</th>
<th>Home_WP_pre</th>
<th>Away_WP_pre</th>
<th>Home_WP_post</th>
<th>Away_WP_post</th>
<th>Win_Prob</th>
<th>WPA</th>
<th>airWPA</th>
<th>yacWPA</th>
<th>Season</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2.014474</td>
<td>NaN</td>
<td>NaN</td>
<td>0.485675</td>
<td>0.514325</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.485675</td>
<td>0.060758</td>
<td>NaN</td>
<td>NaN</td>
<td>2009</td>
</tr>
<tr>
<td>1</td>
<td>0.077907</td>
<td>-1.068169</td>
<td>1.146076</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.546433</td>
<td>0.004655</td>
<td>-0.032244</td>
<td>0.036899</td>
<td>2009</td>
</tr>
<tr>
<td>2</td>
<td>-1.402760</td>
<td>NaN</td>
<td>NaN</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.551088</td>
<td>-0.040295</td>
<td>NaN</td>
<td>NaN</td>
<td>2009</td>
</tr>
<tr>
<td>3</td>
<td>-1.712583</td>
<td>3.318841</td>
<td>-5.031425</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.510793</td>
<td>-0.049576</td>
<td>0.106663</td>
<td>-0.156239</td>
<td>2009</td>
</tr>
<tr>
<td>4</td>
<td>2.097796</td>
<td>NaN</td>
<td>NaN</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.558929</td>
<td>0.441071</td>
<td>0.461217</td>
<td>0.097712</td>
<td>NaN</td>
<td>NaN</td>
<td>2009</td>
</tr>
</tbody>
</table>
</div>
<p>我们可以使用<code>pandas</code>的<code>fillna()</code>函数对数据框中的元素进行填充。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有NA值替换为0</span></span><br><span class="line">subset_nfl_data.fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>EPA</th>
<th>airEPA</th>
<th>yacEPA</th>
<th>Home_WP_pre</th>
<th>Away_WP_pre</th>
<th>Home_WP_post</th>
<th>Away_WP_post</th>
<th>Win_Prob</th>
<th>WPA</th>
<th>airWPA</th>
<th>yacWPA</th>
<th>Season</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2.014474</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.485675</td>
<td>0.514325</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.485675</td>
<td>0.060758</td>
<td>0.000000</td>
<td>0.000000</td>
<td>2009</td>
</tr>
<tr>
<td>1</td>
<td>0.077907</td>
<td>-1.068169</td>
<td>1.146076</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.546433</td>
<td>0.004655</td>
<td>-0.032244</td>
<td>0.036899</td>
<td>2009</td>
</tr>
<tr>
<td>2</td>
<td>-1.402760</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.551088</td>
<td>-0.040295</td>
<td>0.000000</td>
<td>0.000000</td>
<td>2009</td>
</tr>
<tr>
<td>3</td>
<td>-1.712583</td>
<td>3.318841</td>
<td>-5.031425</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.510793</td>
<td>-0.049576</td>
<td>0.106663</td>
<td>-0.156239</td>
<td>2009</td>
</tr>
<tr>
<td>4</td>
<td>2.097796</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.558929</td>
<td>0.441071</td>
<td>0.461217</td>
<td>0.097712</td>
<td>0.000000</td>
<td>0.000000</td>
<td>2009</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有 NA 替换为同一列中紧随其后的值，</span></span><br><span class="line"><span class="comment"># 然后将所有剩余的NA替换为 0</span></span><br><span class="line">subset_nfl_data.fillna(method=<span class="string">&quot;bfill&quot;</span>, axis=<span class="number">0</span>).fillna(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>EPA</th>
<th>airEPA</th>
<th>yacEPA</th>
<th>Home_WP_pre</th>
<th>Away_WP_pre</th>
<th>Home_WP_post</th>
<th>Away_WP_post</th>
<th>Win_Prob</th>
<th>WPA</th>
<th>airWPA</th>
<th>yacWPA</th>
<th>Season</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2.014474</td>
<td>-1.068169</td>
<td>1.146076</td>
<td>0.485675</td>
<td>0.514325</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.485675</td>
<td>0.060758</td>
<td>-0.032244</td>
<td>0.036899</td>
<td>2009</td>
</tr>
<tr>
<td>1</td>
<td>0.077907</td>
<td>-1.068169</td>
<td>1.146076</td>
<td>0.546433</td>
<td>0.453567</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.546433</td>
<td>0.004655</td>
<td>-0.032244</td>
<td>0.036899</td>
<td>2009</td>
</tr>
<tr>
<td>2</td>
<td>-1.402760</td>
<td>3.318841</td>
<td>-5.031425</td>
<td>0.551088</td>
<td>0.448912</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.551088</td>
<td>-0.040295</td>
<td>0.106663</td>
<td>-0.156239</td>
<td>2009</td>
</tr>
<tr>
<td>3</td>
<td>-1.712583</td>
<td>3.318841</td>
<td>-5.031425</td>
<td>0.510793</td>
<td>0.489207</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.510793</td>
<td>-0.049576</td>
<td>0.106663</td>
<td>-0.156239</td>
<td>2009</td>
</tr>
<tr>
<td>4</td>
<td>2.097796</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.461217</td>
<td>0.538783</td>
<td>0.558929</td>
<td>0.441071</td>
<td>0.461217</td>
<td>0.097712</td>
<td>0.000000</td>
<td>0.000000</td>
<td>2009</td>
</tr>
</tbody>
</table>
</div>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> learntools.core <span class="keyword">import</span> binder </span><br><span class="line">binder.bind(<span class="built_in">globals</span>())</span><br><span class="line"><span class="keyword">from</span> learntools.data_cleaning.ex1 <span class="keyword">import</span> *</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Setup Complete!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Take a first look at the data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#modules we&#x27;ll use</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># read in all our data</span></span><br><span class="line">sf_permits = pd.read_csv(<span class="string">&quot;../input/building-permit-applications-data/Building_Permits.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set seed fot reproducibility</span></span><br><span class="line">np.random.seed(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># check the head of the dataset</span></span><br><span class="line">sf_permits.head()</span><br><span class="line"></span><br><span class="line"><span class="comment"># How many missing data points do we have?</span></span><br><span class="line">missing_values_count = sf_permits.isnull().<span class="built_in">sum</span>()</span><br><span class="line">total_cells = np.product(sf_permits.shape)</span><br><span class="line">total_missing = missing_values_count.<span class="built_in">sum</span>()</span><br><span class="line">percent_missing = (total_missing/total_cells)*<span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(percent_missing)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Figure out why the data is missing</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># drop missing values: rows</span></span><br><span class="line">columns_with_na_dropped = sf_permits.dropna()</span><br><span class="line"><span class="built_in">print</span>(columns_with_na_dropped.shape[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># undone</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shaw"
      src="/images/avatar.gif">
  <p class="site-author-name" itemprop="name">Shaw</p>
  <div class="site-description" itemprop="description">Was mich nicht umbringt, macht mich stärker</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021-10 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shaw</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

    <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
    <span class="post-meta-divider">|</span>
    <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>
    <span class="post-meta-divider">|</span>
<!-- 不蒜子计数初始值纠正 -->
<script>
$(document).ready(function() {

    var int = setInterval(fixCount, 50);  // 50ms周期检测函数
    var countOffset = 20000;  // 初始化首次数据

    function fixCount() {            
       if (document.getElementById("busuanzi_container_site_pv").style.display != "none")
        {
            $("#busuanzi_value_site_pv").html(parseInt($("#busuanzi_value_site_pv").html()) + countOffset); 
            clearInterval(int);
        }                  
        if ($("#busuanzi_container_site_pv").css("display") != "none")
        {
            $("#busuanzi_value_site_uv").html(parseInt($("#busuanzi_value_site_uv").html()) + countOffset); // 加上初始数据 
            clearInterval(int); // 停止检测
        }  
    }
       	
});
</script> 

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
